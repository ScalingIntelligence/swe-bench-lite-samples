{
  "info": {
    "duration": 151.48057436943054,
    "submission": "diff --git a/lib/matplotlib/backends/backend_ps.py b/lib/matplotlib/backends/backend_ps.py\nindex f209e811f1..e1c0d3b61a 100644\n--- a/lib/matplotlib/backends/backend_ps.py\n+++ b/lib/matplotlib/backends/backend_ps.py\n@@ -662,11 +662,13 @@ grestore\n                         stream.append(curr_stream)\n                     prev_font = item.ft_object\n                     curr_stream = [ps_name, []]\n-                curr_stream[1].append(\n-                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n-                )\n+                if curr_stream:\n+                    curr_stream[1].append(\n+                        (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n+                    )\n             # append the last entry\n-            stream.append(curr_stream)\n+            if curr_stream:\n+                stream.append(curr_stream)\n \n         self.set_color(*gc.get_rgb())\n \n",
    "total_cost": 0.177525,
    "instance_id": "matplotlib__matplotlib-23964",
    "evaluation_name": "run_on_remaining_250_for_july_4_t_1.6"
  },
  "name": "AgenticLoop",
  "transitions": [
    {
      "name": "SearchCode",
      "state": {
        "model": "deepseek-coder",
        "message": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": null,
        "max_search_results": 25,
        "support_test_files": false,
        "initial_context_tokens": 4000,
        "initial_search_results": 50,
        "include_message_history": true,
        "provide_initial_context": true,
        "initial_context_spans_per_file": 5,
        "max_retries_with_any_file_context": 3
      },
      "actions": [
        {
          "action": {
            "complete": false,
            "scratch_pad": "The issue involves a TypeError related to unpacking a NoneType object when saving a figure using the PostScript backend. This occurs specifically when the figure contains a multi-line text label with an empty line. The specific error traceback points to functionality within the backend_ps.py file. Given the error message and the traceback, it's clear that the issue is related to the PostScript backend file. I will perform a search focusing on the backend_ps.py file to find the exact location of the error by looking for the TypeError message and function where the error occurs.",
            "search_requests": [
              {
                "query": "TypeError: cannot unpack non-iterable NoneType object",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "**/backends/backend_ps.py",
                "function_names": []
              }
            ]
          },
          "output": {
            "complete": false,
            "ranked_spans": [
              {
                "rank": 0,
                "tokens": 366,
                "span_id": "FigureCanvasPS._print_ps",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 0,
                "tokens": 11,
                "span_id": "FigureCanvasPS.get_default_filetype",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 0,
                "tokens": 35,
                "span_id": "FigureCanvasPS",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 1,
                "tokens": 214,
                "span_id": "docstring",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 1,
                "tokens": 5,
                "span_id": "PsBackendHelper",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 1,
                "tokens": 11,
                "span_id": "PsBackendHelper.__init__",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 1,
                "tokens": 374,
                "span_id": "impl:7",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 1,
                "tokens": 50,
                "span_id": "_get_papertype",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 1,
                "tokens": 32,
                "span_id": "_nums_to_str",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 2,
                "tokens": 1172,
                "span_id": "FigureCanvasPS._print_figure",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 4,
                "tokens": 18,
                "span_id": "_BackendPS",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 4,
                "tokens": 447,
                "span_id": "impl:11",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 5,
                "tokens": 105,
                "span_id": "RendererPS._is_transparent",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 6,
                "tokens": 416,
                "span_id": "RendererPS.draw_gouraud_triangles",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 7,
                "tokens": 461,
                "span_id": "pstoeps",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 8,
                "tokens": 30,
                "span_id": "FigureCanvasPS:6",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 8,
                "tokens": 16,
                "span_id": "FigureCanvasPS.draw",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 8,
                "tokens": 679,
                "span_id": "FigureCanvasPS._print_figure_tex",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 9,
                "tokens": 110,
                "span_id": "RendererPS.set_linedash",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 9,
                "tokens": 67,
                "span_id": "RendererPS.set_font",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 10,
                "tokens": 436,
                "span_id": "RendererPS.draw_path_collection",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 11,
                "tokens": 167,
                "span_id": "RendererPS._get_clip_cmd",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 12,
                "tokens": 519,
                "span_id": "RendererPS.draw_text",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 13,
                "tokens": 292,
                "span_id": "gs_distill",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 13,
                "tokens": 52,
                "span_id": "_try_distill",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 14,
                "tokens": 403,
                "span_id": "RendererPS.draw_markers",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              }
            ],
            "search_requests": [
              {
                "query": "TypeError: cannot unpack non-iterable NoneType object",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "**/backends/backend_ps.py",
                "function_names": []
              }
            ]
          },
          "input_tokens": 4911,
          "output_tokens": 217,
          "retry_message": null,
          "completion_cost": 0.017988
        }
      ]
    },
    {
      "name": "IdentifyCode",
      "state": {
        "model": "deepseek-coder",
        "query": null,
        "class_name": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "code_snippet": null,
        "file_pattern": null,
        "ranked_spans": [
          {
            "rank": 0,
            "tokens": 366,
            "span_id": "FigureCanvasPS._print_ps",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 0,
            "tokens": 11,
            "span_id": "FigureCanvasPS.get_default_filetype",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 0,
            "tokens": 35,
            "span_id": "FigureCanvasPS",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 1,
            "tokens": 214,
            "span_id": "docstring",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 1,
            "tokens": 5,
            "span_id": "PsBackendHelper",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 1,
            "tokens": 11,
            "span_id": "PsBackendHelper.__init__",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 1,
            "tokens": 374,
            "span_id": "impl:7",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 1,
            "tokens": 50,
            "span_id": "_get_papertype",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 1,
            "tokens": 32,
            "span_id": "_nums_to_str",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 2,
            "tokens": 1172,
            "span_id": "FigureCanvasPS._print_figure",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 4,
            "tokens": 18,
            "span_id": "_BackendPS",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 4,
            "tokens": 447,
            "span_id": "impl:11",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 5,
            "tokens": 105,
            "span_id": "RendererPS._is_transparent",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 6,
            "tokens": 416,
            "span_id": "RendererPS.draw_gouraud_triangles",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 7,
            "tokens": 461,
            "span_id": "pstoeps",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 8,
            "tokens": 30,
            "span_id": "FigureCanvasPS:6",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 8,
            "tokens": 16,
            "span_id": "FigureCanvasPS.draw",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 8,
            "tokens": 679,
            "span_id": "FigureCanvasPS._print_figure_tex",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 9,
            "tokens": 110,
            "span_id": "RendererPS.set_linedash",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 9,
            "tokens": 67,
            "span_id": "RendererPS.set_font",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 10,
            "tokens": 436,
            "span_id": "RendererPS.draw_path_collection",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 11,
            "tokens": 167,
            "span_id": "RendererPS._get_clip_cmd",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 12,
            "tokens": 519,
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 13,
            "tokens": 292,
            "span_id": "gs_distill",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 13,
            "tokens": 52,
            "span_id": "_try_distill",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 14,
            "tokens": 403,
            "span_id": "RendererPS.draw_markers",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          }
        ],
        "function_name": null,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false
      },
      "actions": [
        {
          "action": {
            "scratch_pad": "The reported issue involves a TypeError when a figure with a multi-line text label containing an empty line is saved using the PostScript backend. The error occurs in the method `RendererPS.draw_text` in `backend_ps.py`. The error message indicates a problem with the `stream` variable unpacking a `NoneType` object, which likely means the `stream` is not properly initialized or checked before being used in the loop. The search results contain several relevant spans, including the `RendererPS.draw_text` method. This method is central to the reported issue as it handles the rendering of text in the PostScript backend. Additionally, the search results include other methods and classes that are part of the PostScript backend rendering process, such as `FigureCanvasPS` and its methods for printing figures. These spans are relevant because they give context to how the PostScript backend functions and processes figure saving.",
            "identified_spans": [
              {
                "span_ids": [
                  "impl:7",
                  "RendererPS",
                  "RendererPS._is_transparent",
                  "RendererPS.set_linedash",
                  "RendererPS.set_font",
                  "RendererPS._get_clip_cmd",
                  "RendererPS.draw_markers",
                  "RendererPS.draw_path_collection",
                  "RendererPS.draw_text",
                  "RendererPS.draw_gouraud_triangles",
                  "FigureCanvasPS",
                  "FigureCanvasPS.get_default_filetype",
                  "FigureCanvasPS._print_ps",
                  "FigureCanvasPS._print_figure",
                  "FigureCanvasPS._print_figure_tex",
                  "FigureCanvasPS:6",
                  "FigureCanvasPS.draw",
                  "impl:11",
                  "_BackendPS"
                ],
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              }
            ]
          },
          "output": {},
          "input_tokens": 5760,
          "output_tokens": 446,
          "retry_message": null,
          "completion_cost": 0.023969999999999998
        }
      ]
    },
    {
      "name": "DecideRelevance",
      "state": {
        "model": "deepseek-coder",
        "max_tokens": 1000,
        "temperature": 1.6,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false,
        "finish_after_relevant_count": 2
      },
      "actions": [
        {
          "action": {
            "complete": true,
            "relevant": true,
            "scratch_pad": "The issue involves a TypeError related to unpacking a NoneType object when saving a figure using the PostScript backend. This occurs specifically when the figure contains a multi-line text label with an empty line. The specific error traceback points to functionality within the backend_ps.py file. Given the error message and the traceback, it's clear that the issue is related to the PostScript backend file. I will perform a search focusing on the backend_ps.py file to find the exact location of the error by looking for the TypeError message and function where the error occurs.",
            "search_suggestions": null
          },
          "output": {},
          "input_tokens": 9433,
          "output_tokens": 157,
          "retry_message": null,
          "completion_cost": 0.030654
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": null,
        "model": "deepseek-coder",
        "message": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "modify",
            "finish": null,
            "reject": null,
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py",
            "scratch_pad": "The issue involves a TypeError when saving a figure with the PostScript backend if the figure contains a multi-line text label with an empty line. The suggested fix is to add a check before unpacking the stream in the draw_text method of the RendererPS class. The suggested line is 'if curr_stream:' before line 669.",
            "instructions": "Add a check 'if curr_stream:' before attempting to unpack the stream in the draw_text method to prevent the TypeError when the stream is None."
          },
          "output": {
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py",
            "instructions": "Add a check 'if curr_stream:' before attempting to unpack the stream in the draw_text method to prevent the TypeError when the stream is None."
          },
          "input_tokens": 9851,
          "output_tokens": 182,
          "retry_message": null,
          "completion_cost": 0.032283
        }
      ]
    },
    {
      "name": "ClarifyCodeChange",
      "state": {
        "model": "deepseek-coder",
        "span_id": "RendererPS.draw_text",
        "end_line": null,
        "file_path": "lib/matplotlib/backends/backend_ps.py",
        "max_tokens": 1000,
        "start_line": null,
        "temperature": 1.6,
        "instructions": "Add a check 'if curr_stream:' before attempting to unpack the stream in the draw_text method to prevent the TypeError when the stream is None.\n\nThe instruction requires adding a check for 'curr_stream' before attempting to unpack it in the 'draw_text' method. This check should be added right before line 661 where the unpacking of 'curr_stream' begins. This ensures that the code does not attempt to unpack 'curr_stream' when it is None, thus preventing a potential TypeError.",
        "max_iterations": null,
        "include_message_history": false,
        "max_tokens_in_edit_prompt": 500
      },
      "actions": [
        {
          "action": {
            "reject": null,
            "end_line": 669,
            "start_line": 656,
            "scratch_pad": "The instruction requires adding a check for 'curr_stream' before attempting to unpack it in the 'draw_text' method. This check should be added right before line 661 where the unpacking of 'curr_stream' begins. This ensures that the code does not attempt to unpack 'curr_stream' when it is None, thus preventing a potential TypeError."
          },
          "output": {
            "span_id": "RendererPS.draw_text",
            "end_line": 669,
            "file_path": "lib/matplotlib/backends/backend_ps.py",
            "start_line": 656,
            "instructions": "Add a check 'if curr_stream:' before attempting to unpack the stream in the draw_text method to prevent the TypeError when the stream is None.\n\nThe instruction requires adding a check for 'curr_stream' before attempting to unpack it in the 'draw_text' method. This check should be added right before line 661 where the unpacking of 'curr_stream' begins. This ensures that the code does not attempt to unpack 'curr_stream' when it is None, thus preventing a potential TypeError."
          },
          "input_tokens": 1517,
          "output_tokens": 122,
          "retry_message": null,
          "completion_cost": 0.006381
        }
      ]
    },
    {
      "name": "EditCode",
      "state": {
        "model": "deepseek-coder",
        "verify": true,
        "span_id": "RendererPS.draw_text",
        "end_line": 669,
        "file_path": "lib/matplotlib/backends/backend_ps.py",
        "max_tokens": 1000,
        "start_line": 656,
        "temperature": 1.6,
        "instructions": "Add a check 'if curr_stream:' before attempting to unpack the stream in the draw_text method to prevent the TypeError when the stream is None.\n\nThe instruction requires adding a check for 'curr_stream' before attempting to unpack it in the 'draw_text' method. This check should be added right before line 661 where the unpacking of 'curr_stream' begins. This ensures that the code does not attempt to unpack 'curr_stream' when it is None, thus preventing a potential TypeError.",
        "max_iterations": 8,
        "chain_of_thought": false,
        "show_file_context": true,
        "show_initial_message": true,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true
      },
      "actions": [
        {
          "action": {
            "content": "```html\n<replace>\n            prev_font = curr_stream = None\n            for item in _text_helpers.layout(s, font):\n                ps_name = (item.ft_object.postscript_name\n                           .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n                if item.ft_object is not prev_font:\n                    if curr_stream:\n                        stream.append(curr_stream)\n                    prev_font = item.ft_object\n                    curr_stream = [ps_name, []]\n                if curr_stream:\n                    curr_stream[1].append(\n                        (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                    )\n            # append the last entry\n            if curr_stream:\n                stream.append(curr_stream)\n</replace>"
          },
          "output": {
            "diff": "--- lib/matplotlib/backends/backend_ps.py\n+++ lib/matplotlib/backends/backend_ps.py\n@@ -662,11 +662,13 @@\n                         stream.append(curr_stream)\n                     prev_font = item.ft_object\n                     curr_stream = [ps_name, []]\n-                curr_stream[1].append(\n-                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n-                )\n+                if curr_stream:\n+                    curr_stream[1].append(\n+                        (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n+                    )\n             # append the last entry\n-            stream.append(curr_stream)\n+            if curr_stream:\n+                stream.append(curr_stream)\n \n         self.set_color(*gc.get_rgb())\n \n",
            "message": "Applied the change to lib/matplotlib/backends/backend_ps.py.\n\n<scratch_pad>\n```html\n</scratch_pad>",
            "verification_errors": []
          },
          "input_tokens": 10107,
          "output_tokens": 192,
          "retry_message": null,
          "completion_cost": 0.033201
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": "--- lib/matplotlib/backends/backend_ps.py\n+++ lib/matplotlib/backends/backend_ps.py\n@@ -662,11 +662,13 @@\n                         stream.append(curr_stream)\n                     prev_font = item.ft_object\n                     curr_stream = [ps_name, []]\n-                curr_stream[1].append(\n-                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n-                )\n+                if curr_stream:\n+                    curr_stream[1].append(\n+                        (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n+                    )\n             # append the last entry\n-            stream.append(curr_stream)\n+            if curr_stream:\n+                stream.append(curr_stream)\n \n         self.set_color(*gc.get_rgb())\n \n",
        "model": "deepseek-coder",
        "message": "Applied the change to lib/matplotlib/backends/backend_ps.py.\n\n<scratch_pad>\n```html\n</scratch_pad>",
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": [],
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "finish",
            "finish": "The issue has been addressed by adding a check to prevent unpacking of a None stream, which was causing the TypeError.",
            "reject": null,
            "span_id": null,
            "file_path": null,
            "scratch_pad": "The change has been applied and the addition of 'if curr_stream:' before unpacking the stream in the draw_text method of the RendererPS class has been verified. This should prevent the TypeError when the stream is None, as reported in the issue.",
            "instructions": null
          },
          "output": {
            "message": "The issue has been addressed by adding a check to prevent unpacking of a None stream, which was causing the TypeError."
          },
          "input_tokens": 10321,
          "output_tokens": 139,
          "retry_message": null,
          "completion_cost": 0.033048
        }
      ]
    },
    {
      "name": "Finished",
      "state": {
        "model": "gpt-4o",
        "output": {
          "model": "deepseek-coder",
          "temperature": 1.6
        },
        "message": "The issue has been addressed by adding a check to prevent unpacking of a None stream, which was causing the TypeError.",
        "max_tokens": 1000,
        "temperature": 0.0,
        "max_iterations": null,
        "include_message_history": false
      },
      "actions": []
    }
  ],
  "initial_message": "[Bug]: Text label with empty line causes a \"TypeError: cannot unpack non-iterable NoneType object\" in PostScript backend\n### Bug summary\n\nWhen saving a figure with the PostScript backend, a\r\n> TypeError: cannot unpack non-iterable NoneType object\r\n\r\nhappens if the figure contains a multi-line text label with an empty line (see example).\n\n### Code for reproduction\n\n```python\nfrom matplotlib.figure import Figure\r\n\r\nfigure = Figure()\r\nax = figure.add_subplot(111)\r\n# ax.set_title('\\nLower title')  # this would cause an error as well\r\nax.annotate(text='\\nLower label', xy=(0, 0))\r\nfigure.savefig('figure.eps')\n```\n\n\n### Actual outcome\n\n$ ./venv/Scripts/python save_ps.py\r\nTraceback (most recent call last):\r\n  File \"C:\\temp\\matplotlib_save_ps\\save_ps.py\", line 7, in <module>\r\n    figure.savefig('figure.eps')\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\figure.py\", line 3272, in savefig\r\n    self.canvas.print_figure(fname, **kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backend_bases.py\", line 2338, in print_figure\r\n    result = print_method(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backend_bases.py\", line 2204, in <lambda>\r\n    print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\_api\\deprecation.py\", line 410, in wrapper\r\n    return func(*inner_args, **inner_kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 869, in _print_ps\r\n    printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 927, in _print_figure\r\n    self.figure.draw(renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 74, in draw_wrapper\r\n    result = draw(artist, renderer, *args, **kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\figure.py\", line 3069, in draw\r\n    mimage._draw_list_compositing_images(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\image.py\", line 131, in _draw_list_compositing_images\r\n    a.draw(renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\axes\\_base.py\", line 3106, in draw\r\n    mimage._draw_list_compositing_images(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\image.py\", line 131, in _draw_list_compositing_images\r\n    a.draw(renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\text.py\", line 1995, in draw\r\n    Text.draw(self, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\text.py\", line 736, in draw\r\n    textrenderer.draw_text(gc, x, y, clean_line,\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 248, in wrapper\r\n    return meth(self, *args, **kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 673, in draw_text\r\n    for ps_name, xs_names in stream:\r\nTypeError: cannot unpack non-iterable NoneType object\r\n\n\n### Expected outcome\n\nThe figure can be saved as `figure.eps` without error.\n\n### Additional information\n\n- seems to happen if a text label or title contains a linebreak with an empty line\r\n- works without error for other backends such as PNG, PDF, SVG, Qt\r\n- works with matplotlib<=3.5.3\r\n- adding `if curr_stream:` before line 669 of `backend_ps.py` seems to fix the bug \n\n### Operating system\n\nWindows\n\n### Matplotlib Version\n\n3.6.0\n\n### Matplotlib Backend\n\n_No response_\n\n### Python version\n\n3.9.13\n\n### Jupyter version\n\n_No response_\n\n### Installation\n\npip\n"
}