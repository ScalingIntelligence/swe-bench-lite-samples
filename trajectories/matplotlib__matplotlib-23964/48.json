{
  "info": {
    "duration": 215.33906888961792,
    "submission": "diff --git a/lib/matplotlib/backends/backend_ps.py b/lib/matplotlib/backends/backend_ps.py\nindex f209e811f1..e1c0d3b61a 100644\n--- a/lib/matplotlib/backends/backend_ps.py\n+++ b/lib/matplotlib/backends/backend_ps.py\n@@ -662,11 +662,13 @@ grestore\n                         stream.append(curr_stream)\n                     prev_font = item.ft_object\n                     curr_stream = [ps_name, []]\n-                curr_stream[1].append(\n-                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n-                )\n+                if curr_stream:\n+                    curr_stream[1].append(\n+                        (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n+                    )\n             # append the last entry\n-            stream.append(curr_stream)\n+            if curr_stream:\n+                stream.append(curr_stream)\n \n         self.set_color(*gc.get_rgb())\n \n",
    "total_cost": 0.19095,
    "instance_id": "matplotlib__matplotlib-23964",
    "evaluation_name": "run_on_remaining_250_for_july_4_t_1.6"
  },
  "name": "AgenticLoop",
  "transitions": [
    {
      "name": "SearchCode",
      "state": {
        "model": "deepseek-coder",
        "message": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": null,
        "max_search_results": 25,
        "support_test_files": false,
        "initial_context_tokens": 4000,
        "initial_search_results": 50,
        "include_message_history": true,
        "provide_initial_context": true,
        "initial_context_spans_per_file": 5,
        "max_retries_with_any_file_context": 3
      },
      "actions": [
        {
          "action": {
            "complete": false,
            "scratch_pad": "The issue is related to a TypeError that occurs when handling a multi-line text label with an empty line using the PostScript backend in Matplotlib. The stack trace indicates that the error occurs specifically in the backend_ps.py file within the draw_text method. Given this context, the focus should be on identifying and testing the part of the code responsible for handling text annotations and potentially adding guards to prevent the TypeError.",
            "search_requests": [
              {
                "query": "TypeError: cannot unpack non-iterable NoneType object",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "**/backends/backend_ps.py",
                "function_names": [
                  "draw_text"
                ]
              }
            ]
          },
          "output": {
            "complete": false,
            "ranked_spans": [
              {
                "rank": 0,
                "tokens": 519,
                "span_id": "RendererPS.draw_text",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              }
            ],
            "search_requests": [
              {
                "query": "TypeError: cannot unpack non-iterable NoneType object",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "**/backends/backend_ps.py",
                "function_names": [
                  "draw_text"
                ]
              }
            ]
          },
          "input_tokens": 4911,
          "output_tokens": 165,
          "retry_message": null,
          "completion_cost": 0.017208
        }
      ]
    },
    {
      "name": "IdentifyCode",
      "state": {
        "model": "deepseek-coder",
        "query": null,
        "class_name": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "code_snippet": null,
        "file_pattern": null,
        "ranked_spans": [
          {
            "rank": 0,
            "tokens": 519,
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          }
        ],
        "function_name": null,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false
      },
      "actions": [
        {
          "action": {
            "scratch_pad": "The reported issue is about a TypeError that occurs when saving a figure with the PostScript backend if it contains a multi-line text label with an empty line. The error specifically mentions a 'TypeError: cannot unpack non-iterable NoneType object' in the PostScript backend code. The provided search results include the code for the 'RendererPS' class, specifically focusing on the 'draw_text' method. This method is crucial because it handles the drawing of text labels, which is directly related to the issue at hand. The 'draw_text' method processes text labels and deals with the creation of PostScript streams for text rendering. The issue might be related to how the 'stream' variable is handled, particularly around the section where the text stream is being built and unpacked. Given the context and the error message, it seems likely that the 'stream' variable might occasionally be 'None' when accessed, causing the unpacking error. This hypothesis is further supported by the suggestion in the issue to potentially add a check for 'if curr_stream:' before processing the 'stream' variable.",
            "identified_spans": [
              {
                "span_ids": [
                  "RendererPS.draw_text"
                ],
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              }
            ]
          },
          "output": {},
          "input_tokens": 3545,
          "output_tokens": 297,
          "retry_message": null,
          "completion_cost": 0.01509
        }
      ]
    },
    {
      "name": "DecideRelevance",
      "state": {
        "model": "deepseek-coder",
        "max_tokens": 1000,
        "temperature": 1.6,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false,
        "finish_after_relevant_count": 2
      },
      "actions": [
        {
          "action": {
            "complete": false,
            "relevant": true,
            "scratch_pad": "The reported issue is related to handling an empty line in a multi-line text label when using the PostScript backend. The stack trace and additional information point to a potential bug in the draw_text method of backend_ps.py. This method is responsible for rendering text annotations. The relevant code spans include the draw_text method itself, which processes text for rendering. The solution mentioned (adding 'if curr_stream:' before line 669) aligns with the content provided in the draw_text method, suggesting that the relevant part of the code for addressing the issue has been identified. However, the exact line (line 669) mentioned in the issue is not present in the provided context, which might be a part of the larger file not included here. Nonetheless, the focus should be on protecting against the TypeError specifically in the section of the draw_text method that processes text streams. This indicates that while the core part of the code responsible for the fix is here, the exact fix might require looking into excluded parts of the file or ensuring the safety of text stream operations.",
            "search_suggestions": "Consider reviewing the rest of backend_ps.py or related files (if not provided here) to identify possibly related methods or configurations that could affect text rendering and might require similar guards against NoneType errors when dealing with text streams."
          },
          "output": {
            "message": "Consider reviewing the rest of backend_ps.py or related files (if not provided here) to identify possibly related methods or configurations that could affect text rendering and might require similar guards against NoneType errors when dealing with text streams."
          },
          "input_tokens": 3445,
          "output_tokens": 307,
          "retry_message": null,
          "completion_cost": 0.01494
        }
      ]
    },
    {
      "name": "SearchCode",
      "state": {
        "model": "deepseek-coder",
        "message": "Consider reviewing the rest of backend_ps.py or related files (if not provided here) to identify possibly related methods or configurations that could affect text rendering and might require similar guards against NoneType errors when dealing with text streams.",
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": null,
        "max_search_results": 25,
        "support_test_files": false,
        "initial_context_tokens": 4000,
        "initial_search_results": 50,
        "include_message_history": true,
        "provide_initial_context": true,
        "initial_context_spans_per_file": 5,
        "max_retries_with_any_file_context": 3
      },
      "actions": [
        {
          "action": {
            "complete": false,
            "scratch_pad": "Based on the provided context from backend_ps.py, it's clear that the draw_text method is central to the issue. The method processes text either by using AFM (Adobe Font Metrics) or TTF (TrueType Font) files, and it appears to handle a stream of text characters. The error occurs when trying to unpack a NoneType object, which is likely related to how the streams are processed, particularly in the part where curr_stream is appended to the stream list. To address this, attention should be given to ensuring that curr_stream is properly initialized and contains valid data before it is iterated over or unpacked. Additionally, reviewing other methods or configurations in backend_ps.py, such as _get_font_afm and _get_font_ttf, which prepare font data for draw_text, could also provide insights into potential sources of NoneType objects.",
            "search_requests": [
              {
                "query": "handling text streams",
                "class_names": [],
                "code_snippet": "for ps_name, xs_names in stream:",
                "file_pattern": "**/backends/backend_ps.py",
                "function_names": []
              },
              {
                "query": "handling font metrics or TrueType fonts",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "**/backends/backend_ps.py",
                "function_names": [
                  "_get_font_afm",
                  "_get_font_ttf"
                ]
              }
            ]
          },
          "output": {
            "complete": false,
            "ranked_spans": [
              {
                "rank": 0,
                "tokens": 519,
                "span_id": "RendererPS.draw_text",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              }
            ],
            "search_requests": [
              {
                "query": "handling text streams",
                "class_names": [],
                "code_snippet": "for ps_name, xs_names in stream:",
                "file_pattern": "**/backends/backend_ps.py",
                "function_names": []
              },
              {
                "query": "handling font metrics or TrueType fonts",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "**/backends/backend_ps.py",
                "function_names": [
                  "_get_font_afm",
                  "_get_font_ttf"
                ]
              }
            ]
          },
          "input_tokens": 6222,
          "output_tokens": 366,
          "retry_message": null,
          "completion_cost": 0.024156000000000004
        }
      ]
    },
    {
      "name": "IdentifyCode",
      "state": {
        "model": "deepseek-coder",
        "query": null,
        "class_name": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "code_snippet": null,
        "file_pattern": null,
        "ranked_spans": [
          {
            "rank": 0,
            "tokens": 519,
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          }
        ],
        "function_name": null,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false
      },
      "actions": [
        {
          "action": {
            "scratch_pad": "The reported issue involves a TypeError when saving a figure with a PostScript backend, specifically when the figure contains a multi-line text label with an empty line. The traceback indicates that the error occurs in the `draw_text` method of the `RendererPS` class in the `backend_ps.py` file. The error message 'cannot unpack non-iterable NoneType object' suggests that the code is attempting to unpack a `None` value, which is likely happening in the `for ps_name, xs_names in stream:` line. This suggests that the `stream` variable is sometimes `None`. From the additional information provided, it seems adding a check for `if curr_stream:` before line 669 could fix the bug. Given the context and the search results, the relevant code spans are the `RendererPS` class definition, its `__init__` method, and the `draw_text` method, specifically focusing on the part where the `stream` variable is manipulated and used. The search results match the context provided and confirm the relevance of this code to the reported issue.",
            "identified_spans": [
              {
                "span_ids": [
                  "RendererPS",
                  "RendererPS.__init__",
                  "RendererPS.draw_text"
                ],
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              }
            ]
          },
          "output": {},
          "input_tokens": 4645,
          "output_tokens": 320,
          "retry_message": null,
          "completion_cost": 0.018735
        }
      ]
    },
    {
      "name": "DecideRelevance",
      "state": {
        "model": "deepseek-coder",
        "max_tokens": 1000,
        "temperature": 1.6,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false,
        "finish_after_relevant_count": 2
      },
      "actions": [
        {
          "action": {
            "complete": true,
            "relevant": true,
            "scratch_pad": "Based on the provided context from backend_ps.py, it's clear that the draw_text method is central to the issue. The method processes text either by using AFM (Adobe Font Metrics) or TTF (TrueType Font) files, and it appears to handle a stream of text characters. The error occurs when trying to unpack a NoneType object, which is likely related to how the streams are processed, particularly in the part where curr_stream is appended to the stream list. To address this, attention should be given to ensuring that curr_stream is properly initialized and contains valid data before it is iterated over or unpacked. Additionally, reviewing other methods or configurations in backend_ps.py, such as _get_font_afm and _get_font_ttf, which prepare font data for draw_text, could also provide insights into potential sources of NoneType objects.",
            "search_suggestions": null
          },
          "output": {},
          "input_tokens": 5833,
          "output_tokens": 220,
          "retry_message": null,
          "completion_cost": 0.020799
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": null,
        "model": "deepseek-coder",
        "message": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "modify",
            "finish": null,
            "reject": null,
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py",
            "scratch_pad": "The issue is related to the handling of multi-line text labels containing an empty line in the PostScript backend. A TypeError is raised because of an attempt to unpack a NoneType object in the text drawing method. The suggested fix is to add a check to ensure the stream is not None before iterating over it.",
            "instructions": "Add a check to ensure that `curr_stream` is not None before attempting to unpack it. This can be done by adding an `if curr_stream:` condition before line 669 of `backend_ps.py`."
          },
          "output": {
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py",
            "instructions": "Add a check to ensure that `curr_stream` is not None before attempting to unpack it. This can be done by adding an `if curr_stream:` condition before line 669 of `backend_ps.py`."
          },
          "input_tokens": 7222,
          "output_tokens": 179,
          "retry_message": null,
          "completion_cost": 0.024351
        }
      ]
    },
    {
      "name": "ClarifyCodeChange",
      "state": {
        "model": "deepseek-coder",
        "span_id": "RendererPS.draw_text",
        "end_line": null,
        "file_path": "lib/matplotlib/backends/backend_ps.py",
        "max_tokens": 1000,
        "start_line": null,
        "temperature": 1.6,
        "instructions": "Add a check to ensure that `curr_stream` is not None before attempting to unpack it. This can be done by adding an `if curr_stream:` condition before line 669 of `backend_ps.py`.\n\nTo ensure `curr_stream` is not None before attempting to unpack it, an `if curr_stream:` condition needs to be added right before the current line where `curr_stream` is being appended to `stream`. This line is currently at line 669.",
        "max_iterations": null,
        "include_message_history": false,
        "max_tokens_in_edit_prompt": 500
      },
      "actions": [
        {
          "action": {
            "reject": null,
            "end_line": 668,
            "start_line": 668,
            "scratch_pad": "To ensure `curr_stream` is not None before attempting to unpack it, an `if curr_stream:` condition needs to be added right before the current line where `curr_stream` is being appended to `stream`. This line is currently at line 669."
          },
          "output": {
            "span_id": "RendererPS.draw_text",
            "end_line": 671,
            "file_path": "lib/matplotlib/backends/backend_ps.py",
            "start_line": 664,
            "instructions": "Add a check to ensure that `curr_stream` is not None before attempting to unpack it. This can be done by adding an `if curr_stream:` condition before line 669 of `backend_ps.py`.\n\nTo ensure `curr_stream` is not None before attempting to unpack it, an `if curr_stream:` condition needs to be added right before the current line where `curr_stream` is being appended to `stream`. This line is currently at line 669."
          },
          "input_tokens": 1534,
          "output_tokens": 96,
          "retry_message": null,
          "completion_cost": 0.0060420000000000005
        }
      ]
    },
    {
      "name": "EditCode",
      "state": {
        "model": "deepseek-coder",
        "verify": true,
        "span_id": "RendererPS.draw_text",
        "end_line": 671,
        "file_path": "lib/matplotlib/backends/backend_ps.py",
        "max_tokens": 1000,
        "start_line": 664,
        "temperature": 1.6,
        "instructions": "Add a check to ensure that `curr_stream` is not None before attempting to unpack it. This can be done by adding an `if curr_stream:` condition before line 669 of `backend_ps.py`.\n\nTo ensure `curr_stream` is not None before attempting to unpack it, an `if curr_stream:` condition needs to be added right before the current line where `curr_stream` is being appended to `stream`. This line is currently at line 669.",
        "max_iterations": 8,
        "chain_of_thought": false,
        "show_file_context": true,
        "show_initial_message": true,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true
      },
      "actions": [
        {
          "action": {
            "content": "<replace>\n                    curr_stream = [ps_name, []]\n                if curr_stream:\n                    curr_stream[1].append(\n                        (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                    )\n            # append the last entry\n            if curr_stream:\n                stream.append(curr_stream)\n\n        self.set_color(*gc.get_rgb())\n</replace>"
          },
          "output": {
            "diff": "--- lib/matplotlib/backends/backend_ps.py\n+++ lib/matplotlib/backends/backend_ps.py\n@@ -662,11 +662,13 @@\n                         stream.append(curr_stream)\n                     prev_font = item.ft_object\n                     curr_stream = [ps_name, []]\n-                curr_stream[1].append(\n-                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n-                )\n+                if curr_stream:\n+                    curr_stream[1].append(\n+                        (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n+                    )\n             # append the last entry\n-            stream.append(curr_stream)\n+            if curr_stream:\n+                stream.append(curr_stream)\n \n         self.set_color(*gc.get_rgb())\n \n",
            "message": "Applied the change to lib/matplotlib/backends/backend_ps.py.",
            "verification_errors": []
          },
          "input_tokens": 7612,
          "output_tokens": 104,
          "retry_message": null,
          "completion_cost": 0.024396
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": "--- lib/matplotlib/backends/backend_ps.py\n+++ lib/matplotlib/backends/backend_ps.py\n@@ -662,11 +662,13 @@\n                         stream.append(curr_stream)\n                     prev_font = item.ft_object\n                     curr_stream = [ps_name, []]\n-                curr_stream[1].append(\n-                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n-                )\n+                if curr_stream:\n+                    curr_stream[1].append(\n+                        (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n+                    )\n             # append the last entry\n-            stream.append(curr_stream)\n+            if curr_stream:\n+                stream.append(curr_stream)\n \n         self.set_color(*gc.get_rgb())\n \n",
        "model": "deepseek-coder",
        "message": "Applied the change to lib/matplotlib/backends/backend_ps.py.",
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": [],
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "finish",
            "finish": "The required changes to handle the empty line in multi-line text labels for the PostScript backend have been implemented as suggested. The TypeError should no longer occur when saving figures with these labels.",
            "reject": null,
            "span_id": null,
            "file_path": null,
            "scratch_pad": "The suggested fix has been successfully applied in the provided git diff. The code now includes the necessary check to ensure `curr_stream` is not None before attempting to unpack it, addressing the TypeError as described in the issue.",
            "instructions": null
          },
          "output": {
            "message": "The required changes to handle the empty line in multi-line text labels for the PostScript backend have been implemented as suggested. The TypeError should no longer occur when saving figures with these labels."
          },
          "input_tokens": 7686,
          "output_tokens": 145,
          "retry_message": null,
          "completion_cost": 0.025233000000000002
        }
      ]
    },
    {
      "name": "Finished",
      "state": {
        "model": "gpt-4o",
        "output": {
          "model": "deepseek-coder",
          "temperature": 1.6
        },
        "message": "The required changes to handle the empty line in multi-line text labels for the PostScript backend have been implemented as suggested. The TypeError should no longer occur when saving figures with these labels.",
        "max_tokens": 1000,
        "temperature": 0.0,
        "max_iterations": null,
        "include_message_history": false
      },
      "actions": []
    }
  ],
  "initial_message": "[Bug]: Text label with empty line causes a \"TypeError: cannot unpack non-iterable NoneType object\" in PostScript backend\n### Bug summary\n\nWhen saving a figure with the PostScript backend, a\r\n> TypeError: cannot unpack non-iterable NoneType object\r\n\r\nhappens if the figure contains a multi-line text label with an empty line (see example).\n\n### Code for reproduction\n\n```python\nfrom matplotlib.figure import Figure\r\n\r\nfigure = Figure()\r\nax = figure.add_subplot(111)\r\n# ax.set_title('\\nLower title')  # this would cause an error as well\r\nax.annotate(text='\\nLower label', xy=(0, 0))\r\nfigure.savefig('figure.eps')\n```\n\n\n### Actual outcome\n\n$ ./venv/Scripts/python save_ps.py\r\nTraceback (most recent call last):\r\n  File \"C:\\temp\\matplotlib_save_ps\\save_ps.py\", line 7, in <module>\r\n    figure.savefig('figure.eps')\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\figure.py\", line 3272, in savefig\r\n    self.canvas.print_figure(fname, **kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backend_bases.py\", line 2338, in print_figure\r\n    result = print_method(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backend_bases.py\", line 2204, in <lambda>\r\n    print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\_api\\deprecation.py\", line 410, in wrapper\r\n    return func(*inner_args, **inner_kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 869, in _print_ps\r\n    printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 927, in _print_figure\r\n    self.figure.draw(renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 74, in draw_wrapper\r\n    result = draw(artist, renderer, *args, **kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\figure.py\", line 3069, in draw\r\n    mimage._draw_list_compositing_images(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\image.py\", line 131, in _draw_list_compositing_images\r\n    a.draw(renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\axes\\_base.py\", line 3106, in draw\r\n    mimage._draw_list_compositing_images(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\image.py\", line 131, in _draw_list_compositing_images\r\n    a.draw(renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\text.py\", line 1995, in draw\r\n    Text.draw(self, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\text.py\", line 736, in draw\r\n    textrenderer.draw_text(gc, x, y, clean_line,\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 248, in wrapper\r\n    return meth(self, *args, **kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 673, in draw_text\r\n    for ps_name, xs_names in stream:\r\nTypeError: cannot unpack non-iterable NoneType object\r\n\n\n### Expected outcome\n\nThe figure can be saved as `figure.eps` without error.\n\n### Additional information\n\n- seems to happen if a text label or title contains a linebreak with an empty line\r\n- works without error for other backends such as PNG, PDF, SVG, Qt\r\n- works with matplotlib<=3.5.3\r\n- adding `if curr_stream:` before line 669 of `backend_ps.py` seems to fix the bug \n\n### Operating system\n\nWindows\n\n### Matplotlib Version\n\n3.6.0\n\n### Matplotlib Backend\n\n_No response_\n\n### Python version\n\n3.9.13\n\n### Jupyter version\n\n_No response_\n\n### Installation\n\npip\n"
}