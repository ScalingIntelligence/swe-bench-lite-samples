{
  "info": {
    "duration": 119.60509538650513,
    "submission": "diff --git a/lib/matplotlib/backends/backend_ps.py b/lib/matplotlib/backends/backend_ps.py\nindex f209e811f1..bd996b7509 100644\n--- a/lib/matplotlib/backends/backend_ps.py\n+++ b/lib/matplotlib/backends/backend_ps.py\n@@ -666,7 +666,8 @@ grestore\n                     (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                 )\n             # append the last entry\n-            stream.append(curr_stream)\n+            if curr_stream:\n+                stream.append(curr_stream)\n \n         self.set_color(*gc.get_rgb())\n \n",
    "total_cost": 0.144786,
    "instance_id": "matplotlib__matplotlib-23964",
    "evaluation_name": "run_on_remaining_250_for_july_4_t_1.6"
  },
  "name": "AgenticLoop",
  "transitions": [
    {
      "name": "SearchCode",
      "state": {
        "model": "deepseek-coder",
        "message": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": null,
        "max_search_results": 25,
        "support_test_files": false,
        "initial_context_tokens": 4000,
        "initial_search_results": 50,
        "include_message_history": true,
        "provide_initial_context": true,
        "initial_context_spans_per_file": 5,
        "max_retries_with_any_file_context": 3
      },
      "actions": [
        {
          "action": {
            "complete": false,
            "scratch_pad": "The issue pertains to a TypeError encountered in the PostScript backend when a figure contains a multi-line text label with an empty line. The error trace indicates that the problematic line is within the backend_ps.py file, specifically in the draw_text method. The provided files do not currently include the relevant backend_ps.py where the error occurs. Therefore, the primary search parameter should be the exact file pattern to focus on the backend_ps.py file directly.",
            "search_requests": [
              {
                "query": "TypeError: cannot unpack non-iterable NoneType object",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "**/lib/matplotlib/backends/backend_ps.py",
                "function_names": []
              }
            ]
          },
          "output": {
            "complete": false,
            "ranked_spans": [
              {
                "rank": 0,
                "tokens": 1172,
                "span_id": "FigureCanvasPS._print_figure",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 1,
                "tokens": 366,
                "span_id": "FigureCanvasPS._print_ps",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 1,
                "tokens": 11,
                "span_id": "FigureCanvasPS.get_default_filetype",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 1,
                "tokens": 35,
                "span_id": "FigureCanvasPS",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 3,
                "tokens": 214,
                "span_id": "docstring",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 3,
                "tokens": 5,
                "span_id": "PsBackendHelper",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 3,
                "tokens": 11,
                "span_id": "PsBackendHelper.__init__",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 3,
                "tokens": 374,
                "span_id": "impl:7",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 3,
                "tokens": 50,
                "span_id": "_get_papertype",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 3,
                "tokens": 32,
                "span_id": "_nums_to_str",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 4,
                "tokens": 18,
                "span_id": "_BackendPS",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 4,
                "tokens": 447,
                "span_id": "impl:11",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 5,
                "tokens": 30,
                "span_id": "FigureCanvasPS:6",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 5,
                "tokens": 16,
                "span_id": "FigureCanvasPS.draw",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 5,
                "tokens": 679,
                "span_id": "FigureCanvasPS._print_figure_tex",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 6,
                "tokens": 461,
                "span_id": "pstoeps",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 7,
                "tokens": 105,
                "span_id": "RendererPS._is_transparent",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 8,
                "tokens": 110,
                "span_id": "RendererPS.set_linedash",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 8,
                "tokens": 67,
                "span_id": "RendererPS.set_font",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 10,
                "tokens": 167,
                "span_id": "RendererPS._get_clip_cmd",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 11,
                "tokens": 519,
                "span_id": "RendererPS.draw_text",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 12,
                "tokens": 403,
                "span_id": "RendererPS.draw_markers",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 13,
                "tokens": 287,
                "span_id": "RendererPS.draw_mathtext",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 13,
                "tokens": 58,
                "span_id": "RendererPS.draw_gouraud_triangle",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 14,
                "tokens": 42,
                "span_id": "RendererPS.set_linecap",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              },
              {
                "rank": 14,
                "tokens": 82,
                "span_id": "RendererPS._linejoin_cmd",
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              }
            ],
            "search_requests": [
              {
                "query": "TypeError: cannot unpack non-iterable NoneType object",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "**/lib/matplotlib/backends/backend_ps.py",
                "function_names": []
              }
            ]
          },
          "input_tokens": 4911,
          "output_tokens": 175,
          "retry_message": null,
          "completion_cost": 0.017358
        }
      ]
    },
    {
      "name": "IdentifyCode",
      "state": {
        "model": "deepseek-coder",
        "query": null,
        "class_name": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "code_snippet": null,
        "file_pattern": null,
        "ranked_spans": [
          {
            "rank": 0,
            "tokens": 1172,
            "span_id": "FigureCanvasPS._print_figure",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 1,
            "tokens": 366,
            "span_id": "FigureCanvasPS._print_ps",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 1,
            "tokens": 11,
            "span_id": "FigureCanvasPS.get_default_filetype",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 1,
            "tokens": 35,
            "span_id": "FigureCanvasPS",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 3,
            "tokens": 214,
            "span_id": "docstring",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 3,
            "tokens": 5,
            "span_id": "PsBackendHelper",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 3,
            "tokens": 11,
            "span_id": "PsBackendHelper.__init__",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 3,
            "tokens": 374,
            "span_id": "impl:7",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 3,
            "tokens": 50,
            "span_id": "_get_papertype",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 3,
            "tokens": 32,
            "span_id": "_nums_to_str",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 4,
            "tokens": 18,
            "span_id": "_BackendPS",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 4,
            "tokens": 447,
            "span_id": "impl:11",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 5,
            "tokens": 30,
            "span_id": "FigureCanvasPS:6",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 5,
            "tokens": 16,
            "span_id": "FigureCanvasPS.draw",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 5,
            "tokens": 679,
            "span_id": "FigureCanvasPS._print_figure_tex",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 6,
            "tokens": 461,
            "span_id": "pstoeps",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 7,
            "tokens": 105,
            "span_id": "RendererPS._is_transparent",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 8,
            "tokens": 110,
            "span_id": "RendererPS.set_linedash",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 8,
            "tokens": 67,
            "span_id": "RendererPS.set_font",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 10,
            "tokens": 167,
            "span_id": "RendererPS._get_clip_cmd",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 11,
            "tokens": 519,
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 12,
            "tokens": 403,
            "span_id": "RendererPS.draw_markers",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 13,
            "tokens": 287,
            "span_id": "RendererPS.draw_mathtext",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 13,
            "tokens": 58,
            "span_id": "RendererPS.draw_gouraud_triangle",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 14,
            "tokens": 42,
            "span_id": "RendererPS.set_linecap",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          },
          {
            "rank": 14,
            "tokens": 82,
            "span_id": "RendererPS._linejoin_cmd",
            "file_path": "lib/matplotlib/backends/backend_ps.py"
          }
        ],
        "function_name": null,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false
      },
      "actions": [
        {
          "action": {
            "scratch_pad": "The reported issue involves a TypeError specifically in the PostScript (PS) backend when handling a multi-line text label with an empty line. The stack trace points to the draw_text method in backend_ps.py as the source of the error. In the provided search results, several relevant code spans are found in the same file (backend_ps.py), including the definitions of RendererPS and its methods such as draw_text and draw_mathtext, which handle text rendering. Additionally, the FigureCanvasPS class and its methods for printing figures (e.g., _print_ps and _print_figure) are relevant, as they are involved in the saving process. The spans id='RendererPS.draw_text', id='RendererPS.draw_mathtext', id='FigureCanvasPS._print_ps', and id='FigureCanvasPS._print_figure' seem particularly pertinent to the issue due to their direct involvement in text rendering and figure saving. Based on the information provided and the alignment with the reported issue, these spans are marked as relevant.",
            "identified_spans": [
              {
                "span_ids": [
                  "RendererPS.draw_text",
                  "RendererPS.draw_mathtext",
                  "FigureCanvasPS._print_ps",
                  "FigureCanvasPS._print_figure"
                ],
                "file_path": "lib/matplotlib/backends/backend_ps.py"
              }
            ]
          },
          "output": {},
          "input_tokens": 5688,
          "output_tokens": 332,
          "retry_message": null,
          "completion_cost": 0.022044
        }
      ]
    },
    {
      "name": "DecideRelevance",
      "state": {
        "model": "deepseek-coder",
        "max_tokens": 1000,
        "temperature": 1.6,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false,
        "finish_after_relevant_count": 2
      },
      "actions": [
        {
          "action": {
            "complete": true,
            "relevant": true,
            "scratch_pad": "The provided file context includes the relevant backend_ps.py file, which contains the draw_text method where the error is reported to occur. The error involves handling multi-line text labels with empty lines, and the traceback points to the draw_text method's stream processing. Examining the _print_figure and draw_text methods within the provided file context, I can confirm that the code directly related to text rendering and PostScript generation is present and relevant to the issue. There are sections dealing with text handling, font processing, and PostScript output that align with the reported bug. Since the necessary methods and logic for addressing the issue are provided in the file context, I can conclude that the file context is relevant and complete for addressing the reported issue.",
            "search_suggestions": null
          },
          "output": {},
          "input_tokens": 7042,
          "output_tokens": 194,
          "retry_message": null,
          "completion_cost": 0.024036
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": null,
        "model": "deepseek-coder",
        "message": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "modify",
            "finish": null,
            "reject": null,
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py",
            "scratch_pad": "The issue is caused by a multi-line text label with an empty line when using the PostScript backend. The fix is to add a check for `curr_stream` before line 669 of `backend_ps.py` to avoid trying to unpack a non-iterable NoneType object. This will ensure that the stream is not None before attempting to iterate over it.",
            "instructions": "Add a check to ensure `curr_stream` is not None before attempting to unpack it. The check should be placed at line 669 of `backend_ps.py`."
          },
          "output": {
            "span_id": "RendererPS.draw_text",
            "file_path": "lib/matplotlib/backends/backend_ps.py",
            "instructions": "Add a check to ensure `curr_stream` is not None before attempting to unpack it. The check should be placed at line 669 of `backend_ps.py`."
          },
          "input_tokens": 7388,
          "output_tokens": 184,
          "retry_message": null,
          "completion_cost": 0.024923999999999998
        }
      ]
    },
    {
      "name": "ClarifyCodeChange",
      "state": {
        "model": "deepseek-coder",
        "span_id": "RendererPS.draw_text",
        "end_line": null,
        "file_path": "lib/matplotlib/backends/backend_ps.py",
        "max_tokens": 1000,
        "start_line": null,
        "temperature": 1.6,
        "instructions": "Add a check to ensure `curr_stream` is not None before attempting to unpack it. The check should be placed at line 669 of `backend_ps.py`.\n\nThe check needs to be added before unpacking `curr_stream` at line 669. The current code directly appends `curr_stream` to `stream` without any checks.",
        "max_iterations": null,
        "include_message_history": false,
        "max_tokens_in_edit_prompt": 500
      },
      "actions": [
        {
          "action": {
            "reject": null,
            "end_line": 668,
            "start_line": 668,
            "scratch_pad": "The check needs to be added before unpacking `curr_stream` at line 669. The current code directly appends `curr_stream` to `stream` without any checks."
          },
          "output": {
            "span_id": "RendererPS.draw_text",
            "end_line": 671,
            "file_path": "lib/matplotlib/backends/backend_ps.py",
            "start_line": 664,
            "instructions": "Add a check to ensure `curr_stream` is not None before attempting to unpack it. The check should be placed at line 669 of `backend_ps.py`.\n\nThe check needs to be added before unpacking `curr_stream` at line 669. The current code directly appends `curr_stream` to `stream` without any checks."
          },
          "input_tokens": 1524,
          "output_tokens": 79,
          "retry_message": null,
          "completion_cost": 0.005757000000000001
        }
      ]
    },
    {
      "name": "EditCode",
      "state": {
        "model": "deepseek-coder",
        "verify": true,
        "span_id": "RendererPS.draw_text",
        "end_line": 671,
        "file_path": "lib/matplotlib/backends/backend_ps.py",
        "max_tokens": 1000,
        "start_line": 664,
        "temperature": 1.6,
        "instructions": "Add a check to ensure `curr_stream` is not None before attempting to unpack it. The check should be placed at line 669 of `backend_ps.py`.\n\nThe check needs to be added before unpacking `curr_stream` at line 669. The current code directly appends `curr_stream` to `stream` without any checks.",
        "max_iterations": 8,
        "chain_of_thought": false,
        "show_file_context": true,
        "show_initial_message": true,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true
      },
      "actions": [
        {
          "action": {
            "content": "```html\n<replace>\n                    curr_stream = [ps_name, []]\n                curr_stream[1].append(\n                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                )\n            # append the last entry\n            if curr_stream:\n                stream.append(curr_stream)\n\n        self.set_color(*gc.get_rgb())\n</replace>"
          },
          "output": {
            "diff": "--- lib/matplotlib/backends/backend_ps.py\n+++ lib/matplotlib/backends/backend_ps.py\n@@ -666,7 +666,8 @@\n                     (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                 )\n             # append the last entry\n-            stream.append(curr_stream)\n+            if curr_stream:\n+                stream.append(curr_stream)\n \n         self.set_color(*gc.get_rgb())\n \n",
            "message": "Applied the change to lib/matplotlib/backends/backend_ps.py.\n\n<scratch_pad>\n```html\n</scratch_pad>",
            "verification_errors": []
          },
          "input_tokens": 7616,
          "output_tokens": 100,
          "retry_message": null,
          "completion_cost": 0.024348
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": "--- lib/matplotlib/backends/backend_ps.py\n+++ lib/matplotlib/backends/backend_ps.py\n@@ -666,7 +666,8 @@\n                     (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n                 )\n             # append the last entry\n-            stream.append(curr_stream)\n+            if curr_stream:\n+                stream.append(curr_stream)\n \n         self.set_color(*gc.get_rgb())\n \n",
        "model": "deepseek-coder",
        "message": "Applied the change to lib/matplotlib/backends/backend_ps.py.\n\n<scratch_pad>\n```html\n</scratch_pad>",
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": [],
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "finish",
            "finish": "The fix for the TypeError when a multi-line text label contains an empty line has been successfully applied. The code now checks that `curr_stream` is not `None` before attempting to append it to the `stream` list, thus preventing the TypeError from occurring.",
            "reject": null,
            "span_id": null,
            "file_path": null,
            "scratch_pad": "The suggested change has been applied successfully. The `if curr_stream:` check ensures that the `curr_stream` object is not `None` before attempting to append it to the `stream` list. This addresses the TypeError reported when a multi-line text label contains an empty line. The change has been applied to the `RendererPS.draw_text` method in `backend_ps.py`.",
            "instructions": null
          },
          "output": {
            "message": "The fix for the TypeError when a multi-line text label contains an empty line has been successfully applied. The code now checks that `curr_stream` is not `None` before attempting to append it to the `stream` list, thus preventing the TypeError from occurring."
          },
          "input_tokens": 7768,
          "output_tokens": 201,
          "retry_message": null,
          "completion_cost": 0.026319000000000002
        }
      ]
    },
    {
      "name": "Finished",
      "state": {
        "model": "gpt-4o",
        "output": {
          "model": "deepseek-coder",
          "temperature": 1.6
        },
        "message": "The fix for the TypeError when a multi-line text label contains an empty line has been successfully applied. The code now checks that `curr_stream` is not `None` before attempting to append it to the `stream` list, thus preventing the TypeError from occurring.",
        "max_tokens": 1000,
        "temperature": 0.0,
        "max_iterations": null,
        "include_message_history": false
      },
      "actions": []
    }
  ],
  "initial_message": "[Bug]: Text label with empty line causes a \"TypeError: cannot unpack non-iterable NoneType object\" in PostScript backend\n### Bug summary\n\nWhen saving a figure with the PostScript backend, a\r\n> TypeError: cannot unpack non-iterable NoneType object\r\n\r\nhappens if the figure contains a multi-line text label with an empty line (see example).\n\n### Code for reproduction\n\n```python\nfrom matplotlib.figure import Figure\r\n\r\nfigure = Figure()\r\nax = figure.add_subplot(111)\r\n# ax.set_title('\\nLower title')  # this would cause an error as well\r\nax.annotate(text='\\nLower label', xy=(0, 0))\r\nfigure.savefig('figure.eps')\n```\n\n\n### Actual outcome\n\n$ ./venv/Scripts/python save_ps.py\r\nTraceback (most recent call last):\r\n  File \"C:\\temp\\matplotlib_save_ps\\save_ps.py\", line 7, in <module>\r\n    figure.savefig('figure.eps')\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\figure.py\", line 3272, in savefig\r\n    self.canvas.print_figure(fname, **kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backend_bases.py\", line 2338, in print_figure\r\n    result = print_method(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backend_bases.py\", line 2204, in <lambda>\r\n    print_method = functools.wraps(meth)(lambda *args, **kwargs: meth(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\_api\\deprecation.py\", line 410, in wrapper\r\n    return func(*inner_args, **inner_kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 869, in _print_ps\r\n    printer(fmt, outfile, dpi=dpi, dsc_comments=dsc_comments,\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 927, in _print_figure\r\n    self.figure.draw(renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 74, in draw_wrapper\r\n    result = draw(artist, renderer, *args, **kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\figure.py\", line 3069, in draw\r\n    mimage._draw_list_compositing_images(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\image.py\", line 131, in _draw_list_compositing_images\r\n    a.draw(renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\axes\\_base.py\", line 3106, in draw\r\n    mimage._draw_list_compositing_images(\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\image.py\", line 131, in _draw_list_compositing_images\r\n    a.draw(renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\text.py\", line 1995, in draw\r\n    Text.draw(self, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\artist.py\", line 51, in draw_wrapper\r\n    return draw(artist, renderer)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\text.py\", line 736, in draw\r\n    textrenderer.draw_text(gc, x, y, clean_line,\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 248, in wrapper\r\n    return meth(self, *args, **kwargs)\r\n  File \"C:\\temp\\matplotlib_save_ps\\venv\\lib\\site-packages\\matplotlib\\backends\\backend_ps.py\", line 673, in draw_text\r\n    for ps_name, xs_names in stream:\r\nTypeError: cannot unpack non-iterable NoneType object\r\n\n\n### Expected outcome\n\nThe figure can be saved as `figure.eps` without error.\n\n### Additional information\n\n- seems to happen if a text label or title contains a linebreak with an empty line\r\n- works without error for other backends such as PNG, PDF, SVG, Qt\r\n- works with matplotlib<=3.5.3\r\n- adding `if curr_stream:` before line 669 of `backend_ps.py` seems to fix the bug \n\n### Operating system\n\nWindows\n\n### Matplotlib Version\n\n3.6.0\n\n### Matplotlib Backend\n\n_No response_\n\n### Python version\n\n3.9.13\n\n### Jupyter version\n\n_No response_\n\n### Installation\n\npip\n"
}