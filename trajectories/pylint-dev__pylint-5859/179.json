{
  "info": {
    "duration": 166.51821970939636,
    "submission": "",
    "total_cost": 0.105786,
    "instance_id": "pylint-dev__pylint-5859",
    "evaluation_name": "run_on_remaining_250_for_july_4_t_1.6"
  },
  "name": "AgenticLoop",
  "transitions": [
    {
      "name": "SearchCode",
      "state": {
        "model": "deepseek-coder",
        "message": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": null,
        "max_search_results": 25,
        "support_test_files": false,
        "initial_context_tokens": 4000,
        "initial_search_results": 50,
        "include_message_history": true,
        "provide_initial_context": true,
        "initial_context_spans_per_file": 5,
        "max_retries_with_any_file_context": 3
      },
      "actions": [
        {
          "action": {
            "complete": false,
            "scratch_pad": "The issue involves the `--notes` option in pylint not recognizing note tags that are entirely punctuation. This might be due to how the note tags are processed or validated. The relevant files to look at would be those where the `--notes` option is handled or where note tags are validated, specifically in the pylint/checkers/misc.py and pylint/lint/pylinter.py files.",
            "search_requests": [
              {
                "query": "handle notes option",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "pylint/checkers/misc.py",
                "function_names": []
              },
              {
                "query": "process notes",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "pylint/lint/pylinter.py",
                "function_names": []
              },
              {
                "query": "parse notes",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "pylint/utils/*.py",
                "function_names": []
              }
            ]
          },
          "output": {
            "complete": false,
            "ranked_spans": [
              {
                "rank": 0,
                "tokens": 269,
                "span_id": "EncodingChecker.process_tokens",
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "rank": 0,
                "tokens": 34,
                "span_id": "register",
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "rank": 1,
                "tokens": 207,
                "span_id": "EncodingChecker",
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "rank": 1,
                "tokens": 82,
                "span_id": "EncodingChecker.open",
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "rank": 2,
                "tokens": 135,
                "span_id": "docstring:23",
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "rank": 2,
                "tokens": 80,
                "span_id": "ByIdManagedMessagesChecker",
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "rank": 2,
                "tokens": 22,
                "span_id": "ByIdManagedMessagesChecker._clear_by_id_managed_msgs",
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "rank": 2,
                "tokens": 24,
                "span_id": "ByIdManagedMessagesChecker._get_by_id_managed_msgs",
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "rank": 3,
                "tokens": 126,
                "span_id": "ByIdManagedMessagesChecker.process_module",
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "rank": 0,
                "tokens": 564,
                "span_id": "PyLinter.process_tokens",
                "file_path": "pylint/lint/pylinter.py"
              },
              {
                "rank": 1,
                "tokens": 405,
                "span_id": "docstring",
                "file_path": "pylint/lint/pylinter.py"
              },
              {
                "rank": 1,
                "tokens": 48,
                "span_id": "_read_stdin",
                "file_path": "pylint/lint/pylinter.py"
              },
              {
                "rank": 1,
                "tokens": 73,
                "span_id": "_load_reporter_by_class",
                "file_path": "pylint/lint/pylinter.py"
              },
              {
                "rank": 2,
                "tokens": 102,
                "span_id": "PyLinter.check_astroid_module",
                "file_path": "pylint/lint/pylinter.py"
              },
              {
                "rank": 3,
                "tokens": 316,
                "span_id": "PyLinter._check_astroid_module",
                "file_path": "pylint/lint/pylinter.py"
              },
              {
                "rank": 4,
                "tokens": 119,
                "span_id": "PyLinter._expand_files",
                "file_path": "pylint/lint/pylinter.py"
              },
              {
                "rank": 5,
                "tokens": 804,
                "span_id": "impl:7",
                "file_path": "pylint/lint/pylinter.py"
              },
              {
                "rank": 6,
                "tokens": 69,
                "span_id": "PyLinter.initialize",
                "file_path": "pylint/lint/pylinter.py"
              },
              {
                "rank": 0,
                "tokens": 445,
                "span_id": "docstring:24",
                "file_path": "pylint/utils/__init__.py"
              },
              {
                "rank": 0,
                "tokens": 222,
                "span_id": "imports:5",
                "file_path": "pylint/utils/__init__.py"
              },
              {
                "rank": 1,
                "tokens": 421,
                "span_id": "docstring",
                "file_path": "pylint/utils/utils.py"
              },
              {
                "rank": 1,
                "tokens": 57,
                "span_id": "normalize_text",
                "file_path": "pylint/utils/utils.py"
              },
              {
                "rank": 1,
                "tokens": 17,
                "span_id": "impl:28",
                "file_path": "pylint/utils/utils.py"
              },
              {
                "rank": 1,
                "tokens": 17,
                "span_id": "cmp",
                "file_path": "pylint/utils/utils.py"
              },
              {
                "rank": 1,
                "tokens": 63,
                "span_id": "diff_string",
                "file_path": "pylint/utils/utils.py"
              },
              {
                "rank": 1,
                "tokens": 89,
                "span_id": "get_module_and_frameid",
                "file_path": "pylint/utils/utils.py"
              },
              {
                "rank": 1,
                "tokens": 46,
                "span_id": "get_rst_title",
                "file_path": "pylint/utils/utils.py"
              }
            ],
            "search_requests": [
              {
                "query": "handle notes option",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "pylint/checkers/misc.py",
                "function_names": []
              },
              {
                "query": "process notes",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "pylint/lint/pylinter.py",
                "function_names": []
              },
              {
                "query": "parse notes",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "pylint/utils/*.py",
                "function_names": []
              }
            ]
          },
          "input_tokens": 3327,
          "output_tokens": 214,
          "retry_message": null,
          "completion_cost": 0.013191000000000001
        }
      ]
    },
    {
      "name": "IdentifyCode",
      "state": {
        "model": "deepseek-coder",
        "query": null,
        "class_name": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "code_snippet": null,
        "file_pattern": null,
        "ranked_spans": [
          {
            "rank": 0,
            "tokens": 269,
            "span_id": "EncodingChecker.process_tokens",
            "file_path": "pylint/checkers/misc.py"
          },
          {
            "rank": 0,
            "tokens": 34,
            "span_id": "register",
            "file_path": "pylint/checkers/misc.py"
          },
          {
            "rank": 0,
            "tokens": 564,
            "span_id": "PyLinter.process_tokens",
            "file_path": "pylint/lint/pylinter.py"
          },
          {
            "rank": 0,
            "tokens": 445,
            "span_id": "docstring:24",
            "file_path": "pylint/utils/__init__.py"
          },
          {
            "rank": 0,
            "tokens": 222,
            "span_id": "imports:5",
            "file_path": "pylint/utils/__init__.py"
          },
          {
            "rank": 1,
            "tokens": 207,
            "span_id": "EncodingChecker",
            "file_path": "pylint/checkers/misc.py"
          },
          {
            "rank": 1,
            "tokens": 82,
            "span_id": "EncodingChecker.open",
            "file_path": "pylint/checkers/misc.py"
          },
          {
            "rank": 1,
            "tokens": 405,
            "span_id": "docstring",
            "file_path": "pylint/lint/pylinter.py"
          },
          {
            "rank": 1,
            "tokens": 48,
            "span_id": "_read_stdin",
            "file_path": "pylint/lint/pylinter.py"
          },
          {
            "rank": 1,
            "tokens": 73,
            "span_id": "_load_reporter_by_class",
            "file_path": "pylint/lint/pylinter.py"
          },
          {
            "rank": 1,
            "tokens": 421,
            "span_id": "docstring",
            "file_path": "pylint/utils/utils.py"
          },
          {
            "rank": 1,
            "tokens": 57,
            "span_id": "normalize_text",
            "file_path": "pylint/utils/utils.py"
          },
          {
            "rank": 1,
            "tokens": 17,
            "span_id": "impl:28",
            "file_path": "pylint/utils/utils.py"
          },
          {
            "rank": 1,
            "tokens": 17,
            "span_id": "cmp",
            "file_path": "pylint/utils/utils.py"
          },
          {
            "rank": 1,
            "tokens": 63,
            "span_id": "diff_string",
            "file_path": "pylint/utils/utils.py"
          },
          {
            "rank": 1,
            "tokens": 89,
            "span_id": "get_module_and_frameid",
            "file_path": "pylint/utils/utils.py"
          },
          {
            "rank": 1,
            "tokens": 46,
            "span_id": "get_rst_title",
            "file_path": "pylint/utils/utils.py"
          },
          {
            "rank": 2,
            "tokens": 135,
            "span_id": "docstring:23",
            "file_path": "pylint/checkers/misc.py"
          },
          {
            "rank": 2,
            "tokens": 80,
            "span_id": "ByIdManagedMessagesChecker",
            "file_path": "pylint/checkers/misc.py"
          },
          {
            "rank": 2,
            "tokens": 22,
            "span_id": "ByIdManagedMessagesChecker._clear_by_id_managed_msgs",
            "file_path": "pylint/checkers/misc.py"
          },
          {
            "rank": 2,
            "tokens": 24,
            "span_id": "ByIdManagedMessagesChecker._get_by_id_managed_msgs",
            "file_path": "pylint/checkers/misc.py"
          },
          {
            "rank": 2,
            "tokens": 102,
            "span_id": "PyLinter.check_astroid_module",
            "file_path": "pylint/lint/pylinter.py"
          },
          {
            "rank": 3,
            "tokens": 126,
            "span_id": "ByIdManagedMessagesChecker.process_module",
            "file_path": "pylint/checkers/misc.py"
          },
          {
            "rank": 3,
            "tokens": 316,
            "span_id": "PyLinter._check_astroid_module",
            "file_path": "pylint/lint/pylinter.py"
          },
          {
            "rank": 4,
            "tokens": 119,
            "span_id": "PyLinter._expand_files",
            "file_path": "pylint/lint/pylinter.py"
          },
          {
            "rank": 5,
            "tokens": 804,
            "span_id": "impl:7",
            "file_path": "pylint/lint/pylinter.py"
          },
          {
            "rank": 6,
            "tokens": 69,
            "span_id": "PyLinter.initialize",
            "file_path": "pylint/lint/pylinter.py"
          }
        ],
        "function_name": null,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false
      },
      "actions": [
        {
          "action": {
            "scratch_pad": "The reported issue is related to the --notes option in Pylint not handling note tags that are entirely punctuation (e.g., `???`). Upon reviewing the search results, I focused on the pylint/checkers/misc.py file where the EncodingChecker class is defined, particularly the process_tokens method within this class. This method is responsible for processing tokens and handling comments, which aligns with the functionality required to address the issue. I also examined the pylint/lint/pylinter.py file for additional context related to token processing and the relevant PyLinter class, although this file is more focused on the overall linting process rather than the specific handling of note tags. The pylint/utils/__init__.py and pylint/utils/utils.py files did not contain relevant code for handling note tags, apart from utility functions. Based on the analysis, the pertinent code spans are found within the EncodingChecker class's process_tokens method and potentially related methods in the same class. These code spans deal with token processing and comment parsing, which are critical for addressing the issue of handling punctuation-only note tags.",
            "identified_spans": [
              {
                "span_ids": [
                  "impl:28",
                  "cmp",
                  "diff_string",
                  "get_module_and_frameid",
                  "get_rst_title"
                ],
                "file_path": "pylint/checkers/misc.py"
              },
              {
                "span_ids": [
                  "docstring",
                  "_read_stdin",
                  "_load_reporter_by_class",
                  "impl:7",
                  "PyLinter",
                  "PyLinter.process_tokens",
                  "PyLinter.initialize",
                  "PyLinter._expand_files",
                  "PyLinter.check_astroid_module",
                  "PyLinter._check_astroid_module"
                ],
                "file_path": "pylint/lint/pylinter.py"
              }
            ]
          },
          "output": {},
          "input_tokens": 4641,
          "output_tokens": 468,
          "retry_message": null,
          "completion_cost": 0.020943
        }
      ]
    },
    {
      "name": "DecideRelevance",
      "state": {
        "model": "deepseek-coder",
        "max_tokens": 1000,
        "temperature": 1.6,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false,
        "finish_after_relevant_count": 2
      },
      "actions": [
        {
          "action": {
            "complete": false,
            "relevant": true,
            "scratch_pad": "The file context provided is from `pylint/lint/pylinter.py`, which is relevant as it contains the `PyLinter` class where the `--notes` option is likely handled or where note tags are validated. However, the specific handling of the `--notes` option and the validation of note tags that are entirely punctuation are not directly seen in the provided code snippet. The code snippet includes methods like `process_tokens` and `initialize`, which might be relevant for processing and initializing note tags, but without seeing the exact implementation of the `--notes` option within these methods, it is not possible to confirm that all relevant code is present. Further investigation into the exact handling of the `--notes` option within these methods or related methods would be necessary.",
            "search_suggestions": "Look into the `process_tokens` and `initialize` methods within `pylint/lint/pylinter.py` to find the specific implementation of the `--notes` option and how note tags are validated, especially those entirely composed of punctuation."
          },
          "output": {
            "message": "Look into the `process_tokens` and `initialize` methods within `pylint/lint/pylinter.py` to find the specific implementation of the `--notes` option and how note tags are validated, especially those entirely composed of punctuation."
          },
          "input_tokens": 5274,
          "output_tokens": 247,
          "retry_message": null,
          "completion_cost": 0.019527
        }
      ]
    },
    {
      "name": "SearchCode",
      "state": {
        "model": "deepseek-coder",
        "message": "Look into the `process_tokens` and `initialize` methods within `pylint/lint/pylinter.py` to find the specific implementation of the `--notes` option and how note tags are validated, especially those entirely composed of punctuation.",
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": null,
        "max_search_results": 25,
        "support_test_files": false,
        "initial_context_tokens": 4000,
        "initial_search_results": 50,
        "include_message_history": true,
        "provide_initial_context": true,
        "initial_context_spans_per_file": 5,
        "max_retries_with_any_file_context": 3
      },
      "actions": [
        {
          "action": {
            "complete": true,
            "scratch_pad": "The `process_tokens` method in `pylint/lint/pylinter.py` handles token processing, including inline option parsing. The issue of note tags entirely composed of punctuation not being recognized can be traced back to how note tags are processed within this method. Additionally, the `initialize` method might also be relevant as it initializes the state of messages, which could include note tags. Both methods should be carefully examined to ensure proper handling and validation of note tags, especially those composed entirely of punctuation.",
            "search_requests": [
              {
                "query": "handle note tags composed of punctuation",
                "class_names": [],
                "code_snippet": null,
                "file_pattern": "pylint/lint/pylinter.py",
                "function_names": [
                  "process_tokens",
                  "initialize"
                ]
              }
            ]
          },
          "output": {
            "message": "The `process_tokens` method in `pylint/lint/pylinter.py` handles token processing, including inline option parsing. The issue of note tags entirely composed of punctuation not being recognized can be traced back to how note tags are processed within this method. Additionally, the `initialize` method might also be relevant as it initializes the state of messages, which could include note tags. Both methods should be carefully examined to ensure proper handling and validation of note tags, especially those composed entirely of punctuation."
          },
          "input_tokens": 7728,
          "output_tokens": 209,
          "retry_message": null,
          "completion_cost": 0.026319
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": null,
        "model": "deepseek-coder",
        "message": "The `process_tokens` method in `pylint/lint/pylinter.py` handles token processing, including inline option parsing. The issue of note tags entirely composed of punctuation not being recognized can be traced back to how note tags are processed within this method. Additionally, the `initialize` method might also be relevant as it initializes the state of messages, which could include note tags. Both methods should be carefully examined to ensure proper handling and validation of note tags, especially those composed entirely of punctuation.",
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "modify",
            "finish": null,
            "reject": null,
            "span_id": "PyLinter.process_tokens",
            "file_path": "pylint/lint/pylinter.py",
            "scratch_pad": "The issue involves note tags that are entirely punctuation not being recognized by pylint when specified in the `--notes` option. This likely due to how the notes are processed in the `process_tokens` method. I will examine this method to ensure that note tags, even those composed entirely of punctuation, are properly handled and validated.",
            "instructions": "Update the `process_tokens` method to ensure that note tags, including those composed entirely of punctuation, are properly recognized and processed."
          },
          "output": {
            "span_id": "PyLinter.process_tokens",
            "file_path": "pylint/lint/pylinter.py",
            "instructions": "Update the `process_tokens` method to ensure that note tags, including those composed entirely of punctuation, are properly recognized and processed."
          },
          "input_tokens": 5720,
          "output_tokens": 158,
          "retry_message": null,
          "completion_cost": 0.019530000000000002
        }
      ]
    },
    {
      "name": "ClarifyCodeChange",
      "state": {
        "model": "deepseek-coder",
        "span_id": "PyLinter.process_tokens",
        "end_line": null,
        "file_path": "pylint/lint/pylinter.py",
        "max_tokens": 1000,
        "start_line": null,
        "temperature": 1.6,
        "instructions": "Update the `process_tokens` method to ensure that note tags, including those composed entirely of punctuation, are properly recognized and processed.\n\nThe current implementation does not explicitly handle note tags composed entirely of punctuation. To ensure proper recognition and processing, the logic related to parsing pragmas (line 883-931) and handling unknown or invalid options (932-939) should be updated.",
        "max_iterations": null,
        "include_message_history": false,
        "max_tokens_in_edit_prompt": 500
      },
      "actions": [
        {
          "action": {
            "reject": null,
            "end_line": 931,
            "start_line": 883,
            "scratch_pad": "The current implementation does not explicitly handle note tags composed entirely of punctuation. To ensure proper recognition and processing, the logic related to parsing pragmas (line 883-931) and handling unknown or invalid options (932-939) should be updated."
          },
          "output": {
            "span_id": "PyLinter.process_tokens",
            "end_line": 931,
            "file_path": "pylint/lint/pylinter.py",
            "start_line": 883,
            "instructions": "Update the `process_tokens` method to ensure that note tags, including those composed entirely of punctuation, are properly recognized and processed.\n\nThe current implementation does not explicitly handle note tags composed entirely of punctuation. To ensure proper recognition and processing, the logic related to parsing pragmas (line 883-931) and handling unknown or invalid options (932-939) should be updated."
          },
          "input_tokens": 1607,
          "output_tokens": 97,
          "retry_message": null,
          "completion_cost": 0.006276
        }
      ]
    },
    {
      "name": "EditCode",
      "state": {
        "model": "deepseek-coder",
        "verify": true,
        "span_id": "PyLinter.process_tokens",
        "end_line": 931,
        "file_path": "pylint/lint/pylinter.py",
        "max_tokens": 1000,
        "start_line": 883,
        "temperature": 1.6,
        "instructions": "Update the `process_tokens` method to ensure that note tags, including those composed entirely of punctuation, are properly recognized and processed.\n\nThe current implementation does not explicitly handle note tags composed entirely of punctuation. To ensure proper recognition and processing, the logic related to parsing pragmas (line 883-931) and handling unknown or invalid options (932-939) should be updated.",
        "max_iterations": 8,
        "chain_of_thought": false,
        "show_file_context": true,
        "show_initial_message": true,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true
      },
      "actions": [
        {
          "action": {
            "content": "```json\n{\"replace\":\"                for pragma_repr in parse_pragma(match.group(2)):\n                    if pragma_repr.action in {\\\"disable-all\\\", \\\"skip-file\\\"}:\n                        if pragma_repr.action == \\\"disable-all\\\":\n                            self.add_message(\n                                \\\"deprecated-pragma\\\",\n                                line=start[0],\n                                args=(\\\"disable-all\\\", \\\"skip-file\\\"),\n                            )\n                        self.add_message(\\\"file-ignored\\\", line=start[0])\n                        self._ignore_file = True\n                        return\n                    try:\n                        meth = self._options_methods[pragma_repr.action]\n                    except KeyError:\n                        meth = self._bw_options_methods[pragma_repr.action]\n                        # found a \\\"(dis|en)able-msg\\\" pragma deprecated suppression\n                        self.add_message(\n                            \\\"deprecated-pragma\\\",\n                            line=start[0],\n                            args=(\n                                pragma_repr.action,\n                                pragma_repr.action.replace(\\\"-msg\\\", \\\"\\\"),\n                            ),\n                        )\n                    for msgid in pragma_repr.messages:\n                        # Add the line where a control pragma was encountered.\n                        if pragma_repr.action in control_pragmas:\n                            self._pragma_lineno[msgid] = start[0]\n\n                        if (pragma_repr.action, msgid) == (\\\"disable\\\", \\\"all\\\"):\n                            self.add_message(\n                                \\\"deprecated-pragma\\\",\n                                line=start[0],\n                                args=(\\\"disable=all\\\", \\\"skip-file\\\"),\n                            )\n                            self.add_message(\\\"file-ignored\\\", line=start[0])\n                            self._ignore_file = True\n                            return\n                            # If we did not see a newline between the previous line and now,\n                            # we saw a backslash so treat the two lines as one.\n                        l_start = start[0]\n                        if not saw_newline:\n                            l_start -= 1\n                        try:\n                            meth(msgid, \\\"module\\\", l_start)\n                        except exceptions.UnknownMessageError:\n                            self.add_message(\n                                \\\"bad-option-value\\\", args=msgid, line=start[0]\n                            )\n                        except exceptions.InvalidMessageError:\n                            self.add_message(\n                                \\\"bad-option-value\\\", args=msgid, line=start[0]\n                            )\"}\n\n```"
          },
          "output": null,
          "input_tokens": 6528,
          "output_tokens": 569,
          "retry_message": "You did not provide any code in the replace tag. If you want to reject the instructions, use the reject function.",
          "completion_cost": 0.028119
        },
        {
          "action": {
            "content": "```json\n{\"reject\":\"The instructions do not specify how to handle note tags composed entirely of punctuation within the `process_tokens` method. Detailed implementation steps or logic to process such note tags are required to proceed with the changes.\"}\n```"
          },
          "output": null,
          "input_tokens": 7128,
          "output_tokens": 50,
          "retry_message": "You did not provide any code in the replace tag. If you want to reject the instructions, use the reject function.",
          "completion_cost": 0.022134
        },
        {
          "action": {
            "content": "```json\n{\"reject\":\"The instructions do not specify the additional logic required to properly recognize and process note tags composed entirely of punctuation. Specifically, there is a lack of guidance on how to alter the parsing of pragmas or handling of unknown/invalid options to accommodate such tags.\"}\n```"
          },
          "output": null,
          "input_tokens": 7209,
          "output_tokens": 59,
          "retry_message": "You did not provide any code in the replace tag. If you want to reject the instructions, use the reject function.",
          "completion_cost": 0.022512
        }
      ]
    }
  ],
  "initial_message": "\"--notes\" option ignores note tags that are entirely punctuation\n### Bug description\n\nIf a note tag specified with the `--notes` option is entirely punctuation, pylint won't report a fixme warning (W0511).\r\n\r\n```python\r\n# YES: yes\r\n# ???: no\r\n```\r\n\r\n`pylint test.py --notes=\"YES,???\"` will return a fixme warning (W0511) for the first line, but not the second.\n\n### Configuration\n\n```ini\nDefault\n```\n\n\n### Command used\n\n```shell\npylint test.py --notes=\"YES,???\"\n```\n\n\n### Pylint output\n\n```shell\n************* Module test\r\ntest.py:1:1: W0511: YES: yes (fixme)\n```\n\n\n### Expected behavior\n\n```\r\n************* Module test\r\ntest.py:1:1: W0511: YES: yes (fixme)\r\ntest.py:2:1: W0511: ???: no (fixme)\r\n```\n\n### Pylint version\n\n```shell\npylint 2.12.2\r\nastroid 2.9.0\r\nPython 3.10.2 (main, Feb  2 2022, 05:51:25) [Clang 13.0.0 (clang-1300.0.29.3)]\n```\n\n\n### OS / Environment\n\nmacOS 11.6.1\n\n### Additional dependencies\n\n_No response_\n"
}