{
  "info": {
    "duration": 166.00055861473083,
    "submission": "diff --git a/django/views/debug.py b/django/views/debug.py\nindex e6b7d4d821..70166cd410 100644\n--- a/django/views/debug.py\n+++ b/django/views/debug.py\n@@ -90,6 +90,12 @@ class SafeExceptionReporterFilter:\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, list):\n+                cleansed = [self.cleanse_setting(key, v) for v in value]\n+            elif isinstance(value, (list, tuple, set)):\n+                cleansed = type(value)(self.cleanse_setting(key, sub_value) for sub_value in value)\n+            elif isinstance(value, (dict, list, tuple, set)):\n+                cleansed = type(value)(self.cleanse_setting(key, sub_value) for sub_value in value)\n             else:\n                 cleansed = value\n         except TypeError:\n",
    "total_cost": 0.10708200000000001,
    "instance_id": "django__django-12700",
    "evaluation_name": "run_on_remaining_250_for_july_4_t_1.6"
  },
  "name": "AgenticLoop",
  "transitions": [
    {
      "name": "SearchCode",
      "state": {
        "model": "deepseek-coder",
        "message": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": null,
        "max_search_results": 25,
        "support_test_files": false,
        "initial_context_tokens": 4000,
        "initial_search_results": 50,
        "include_message_history": true,
        "provide_initial_context": true,
        "initial_context_spans_per_file": 5,
        "max_retries_with_any_file_context": 3
      },
      "actions": [
        {
          "action": {
            "complete": false,
            "scratch_pad": "The issue pertains to insufficient cleansing of settings, particularly with iterable types like lists and tuples, which are being returned as-is without proper security treatment. This vulnerability allows sensitive information to be exposed. Focus should be on the SafeExceptionReporterFilter class and its methods, specifically get_safe_settings() and cleanse_setting(). The main logic that handles settings cleansing and the definition of these methods should be investigated.",
            "search_requests": [
              {
                "query": "SafeExceptionReporterFilter cleanse_setting",
                "class_names": [
                  "SafeExceptionReporterFilter"
                ],
                "code_snippet": null,
                "file_pattern": "**/django/views/debug.py",
                "function_names": [
                  "get_safe_settings",
                  "cleanse_setting"
                ]
              }
            ]
          },
          "output": {
            "complete": false,
            "ranked_spans": [
              {
                "rank": 0,
                "tokens": 140,
                "span_id": "SafeExceptionReporterFilter.cleanse_setting",
                "file_path": "django/views/debug.py"
              },
              {
                "rank": 0,
                "tokens": 63,
                "span_id": "SafeExceptionReporterFilter",
                "file_path": "django/views/debug.py"
              },
              {
                "rank": 1,
                "tokens": 65,
                "span_id": "SafeExceptionReporterFilter.get_safe_settings",
                "file_path": "django/views/debug.py"
              },
              {
                "rank": 1,
                "tokens": 57,
                "span_id": "SafeExceptionReporterFilter.get_safe_request_meta",
                "file_path": "django/views/debug.py"
              },
              {
                "rank": 1,
                "tokens": 70,
                "span_id": "SafeExceptionReporterFilter.is_active",
                "file_path": "django/views/debug.py"
              },
              {
                "rank": 2,
                "tokens": 125,
                "span_id": "SafeExceptionReporterFilter.cleanse_special_types",
                "file_path": "django/views/debug.py"
              },
              {
                "rank": 3,
                "tokens": 133,
                "span_id": "SafeExceptionReporterFilter.get_cleansed_multivaluedict",
                "file_path": "django/views/debug.py"
              },
              {
                "rank": 4,
                "tokens": 154,
                "span_id": "SafeExceptionReporterFilter.get_post_parameters",
                "file_path": "django/views/debug.py"
              },
              {
                "rank": 5,
                "tokens": 427,
                "span_id": "SafeExceptionReporterFilter.get_traceback_frame_variables",
                "file_path": "django/views/debug.py"
              }
            ],
            "search_requests": [
              {
                "query": "SafeExceptionReporterFilter cleanse_setting",
                "class_names": [
                  "SafeExceptionReporterFilter"
                ],
                "code_snippet": null,
                "file_pattern": "**/django/views/debug.py",
                "function_names": [
                  "get_safe_settings",
                  "cleanse_setting"
                ]
              }
            ]
          },
          "input_tokens": 3302,
          "output_tokens": 194,
          "retry_message": null,
          "completion_cost": 0.012816000000000001
        }
      ]
    },
    {
      "name": "IdentifyCode",
      "state": {
        "model": "deepseek-coder",
        "query": null,
        "class_name": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "code_snippet": null,
        "file_pattern": null,
        "ranked_spans": [
          {
            "rank": 0,
            "tokens": 140,
            "span_id": "SafeExceptionReporterFilter.cleanse_setting",
            "file_path": "django/views/debug.py"
          },
          {
            "rank": 0,
            "tokens": 63,
            "span_id": "SafeExceptionReporterFilter",
            "file_path": "django/views/debug.py"
          },
          {
            "rank": 1,
            "tokens": 65,
            "span_id": "SafeExceptionReporterFilter.get_safe_settings",
            "file_path": "django/views/debug.py"
          },
          {
            "rank": 1,
            "tokens": 57,
            "span_id": "SafeExceptionReporterFilter.get_safe_request_meta",
            "file_path": "django/views/debug.py"
          },
          {
            "rank": 1,
            "tokens": 70,
            "span_id": "SafeExceptionReporterFilter.is_active",
            "file_path": "django/views/debug.py"
          },
          {
            "rank": 2,
            "tokens": 125,
            "span_id": "SafeExceptionReporterFilter.cleanse_special_types",
            "file_path": "django/views/debug.py"
          },
          {
            "rank": 3,
            "tokens": 133,
            "span_id": "SafeExceptionReporterFilter.get_cleansed_multivaluedict",
            "file_path": "django/views/debug.py"
          },
          {
            "rank": 4,
            "tokens": 154,
            "span_id": "SafeExceptionReporterFilter.get_post_parameters",
            "file_path": "django/views/debug.py"
          },
          {
            "rank": 5,
            "tokens": 427,
            "span_id": "SafeExceptionReporterFilter.get_traceback_frame_variables",
            "file_path": "django/views/debug.py"
          }
        ],
        "function_name": null,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false
      },
      "actions": [
        {
          "action": {
            "scratch_pad": "The reported issue highlights the need to ensure that settings are thoroughly cleansed of sensitive information, including handling various types of iterables beyond just dictionaries. The current implementation in `SafeExceptionReporterFilter.cleanse_setting` only processes dictionaries, leaving other iterable types unhandled. The example provided in the issue demonstrates how nested lists of dictionaries with sensitive data are not sufficiently cleansed. The search results include the `django/views/debug.py` file, which contains the `SafeExceptionReporterFilter` class, including its methods `cleanse_setting` and `get_safe_settings`. These methods need to be evaluated and potentially modified to address the issue of inadequate cleansing of iterable settings. Since the `cleanse_setting` method is where the bulk of the cleansing logic resides, it is the primary focus for addressing this issue. Identifying this span is crucial as altering it will likely resolve the problem of insufficient cleansing in the settings.",
            "identified_spans": [
              {
                "span_ids": [
                  "SafeExceptionReporterFilter.cleanse_setting",
                  "SafeExceptionReporterFilter.get_safe_settings"
                ],
                "file_path": "django/views/debug.py"
              }
            ]
          },
          "output": {},
          "input_tokens": 3177,
          "output_tokens": 270,
          "retry_message": null,
          "completion_cost": 0.013581
        }
      ]
    },
    {
      "name": "DecideRelevance",
      "state": {
        "model": "deepseek-coder",
        "max_tokens": 1000,
        "temperature": 1.6,
        "expand_context": true,
        "max_iterations": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": false,
        "finish_after_relevant_count": 2
      },
      "actions": [
        {
          "action": {
            "complete": true,
            "relevant": true,
            "scratch_pad": "The file context contains the relevant class SafeExceptionReporterFilter with the methods get_safe_settings() and cleanse_setting(). The current implementation of cleanse_setting() only handles dicts and returns other types of iterables as-is, which aligns with the reported issue. Since the methods in question are present along with the logic that needs to be updated to handle other iterable types, the relevant file context is provided.",
            "search_suggestions": null
          },
          "output": {},
          "input_tokens": 1891,
          "output_tokens": 123,
          "retry_message": null,
          "completion_cost": 0.007518
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": null,
        "model": "deepseek-coder",
        "message": null,
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": null,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "modify",
            "finish": null,
            "reject": null,
            "span_id": "SafeExceptionReporterFilter.cleanse_setting",
            "file_path": "django/views/debug.py",
            "scratch_pad": "The current implementation of `cleanse_setting` only handles `dict` types, but other iterable types like lists and nested lists are returned as-is, which can expose sensitive information. To address this, we need to update the `cleanse_setting` method to recursively cleanse all types of iterables.",
            "instructions": "Update the `cleanse_setting` method to handle all types of iterables, including lists and nested lists."
          },
          "output": {
            "span_id": "SafeExceptionReporterFilter.cleanse_setting",
            "end_line": 102,
            "file_path": "django/views/debug.py",
            "start_line": 83,
            "instructions": "Update the `cleanse_setting` method to handle all types of iterables, including lists and nested lists."
          },
          "input_tokens": 2166,
          "output_tokens": 163,
          "retry_message": null,
          "completion_cost": 0.008943
        }
      ]
    },
    {
      "name": "EditCode",
      "state": {
        "model": "deepseek-coder",
        "verify": true,
        "span_id": "SafeExceptionReporterFilter.cleanse_setting",
        "end_line": 102,
        "file_path": "django/views/debug.py",
        "max_tokens": 1000,
        "start_line": 83,
        "temperature": 1.6,
        "instructions": "Update the `cleanse_setting` method to handle all types of iterables, including lists and nested lists.",
        "max_iterations": 8,
        "chain_of_thought": false,
        "show_file_context": true,
        "show_initial_message": true,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true
      },
      "actions": [
        {
          "action": {
            "content": "```markdown\n<replace>\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, list):\n                cleansed = [self.cleanse_setting(key, v) for v in value]\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n\n        if callable(cleansed):\n            cleansed = CallableSettingWrapper(cleansed)\n\n        return cleansed\n</replace>"
          },
          "output": {
            "diff": "--- django/views/debug.py\n+++ django/views/debug.py\n@@ -90,6 +90,8 @@\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, list):\n+                cleansed = [self.cleanse_setting(key, v) for v in value]\n             else:\n                 cleansed = value\n         except TypeError:\n",
            "message": "Applied the change to django/views/debug.py.\n\n<scratch_pad>\n```markdown\n</scratch_pad>",
            "verification_errors": []
          },
          "input_tokens": 2052,
          "output_tokens": 228,
          "retry_message": null,
          "completion_cost": 0.009576000000000001
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": "--- django/views/debug.py\n+++ django/views/debug.py\n@@ -90,6 +90,8 @@\n                 cleansed = self.cleansed_substitute\n             elif isinstance(value, dict):\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n+            elif isinstance(value, list):\n+                cleansed = [self.cleanse_setting(key, v) for v in value]\n             else:\n                 cleansed = value\n         except TypeError:\n",
        "model": "deepseek-coder",
        "message": "Applied the change to django/views/debug.py.\n\n<scratch_pad>\n```markdown\n</scratch_pad>",
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": [],
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "modify",
            "finish": null,
            "reject": null,
            "span_id": "SafeExceptionReporterFilter.cleanse_setting",
            "file_path": "django/views/debug.py",
            "scratch_pad": "The initial change to handle lists has been correctly applied. However, the example provided in the issue reveals that nested lists are still not sufficiently cleansed. We need to ensure that the cleansing process is applied recursively to nested lists as well.",
            "instructions": "Update the `cleanse_setting` method to recursively handle nested lists."
          },
          "output": {
            "span_id": "SafeExceptionReporterFilter.cleanse_setting",
            "end_line": 104,
            "file_path": "django/views/debug.py",
            "start_line": 83,
            "instructions": "Update the `cleanse_setting` method to recursively handle nested lists."
          },
          "input_tokens": 2534,
          "output_tokens": 139,
          "retry_message": null,
          "completion_cost": 0.009687000000000001
        }
      ]
    },
    {
      "name": "EditCode",
      "state": {
        "model": "deepseek-coder",
        "verify": true,
        "span_id": "SafeExceptionReporterFilter.cleanse_setting",
        "end_line": 104,
        "file_path": "django/views/debug.py",
        "max_tokens": 1000,
        "start_line": 83,
        "temperature": 1.6,
        "instructions": "Update the `cleanse_setting` method to recursively handle nested lists.",
        "max_iterations": 8,
        "chain_of_thought": false,
        "show_file_context": true,
        "show_initial_message": true,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true
      },
      "actions": [
        {
          "action": {
            "content": "```xml\n<replace>\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, list):\n                cleansed = [self.cleanse_setting(key, v) for v in value]\n            elif isinstance(value, (list, tuple)):\n                cleansed = [self.cleanse_setting(key, sub_value) for sub_value in value]\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n\n        if callable(cleansed):\n            cleansed = CallableSettingWrapper(cleansed)\n\n        return cleansed\n</replace>"
          },
          "output": {
            "diff": "--- django/views/debug.py\n+++ django/views/debug.py\n@@ -92,6 +92,8 @@\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n             elif isinstance(value, list):\n                 cleansed = [self.cleanse_setting(key, v) for v in value]\n+            elif isinstance(value, (list, tuple)):\n+                cleansed = [self.cleanse_setting(key, sub_value) for sub_value in value]\n             else:\n                 cleansed = value\n         except TypeError:\n",
            "message": "Applied the change to django/views/debug.py.\n\n<scratch_pad>\n```xml\n</scratch_pad>",
            "verification_errors": []
          },
          "input_tokens": 2106,
          "output_tokens": 266,
          "retry_message": null,
          "completion_cost": 0.010308000000000001
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": "--- django/views/debug.py\n+++ django/views/debug.py\n@@ -92,6 +92,8 @@\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n             elif isinstance(value, list):\n                 cleansed = [self.cleanse_setting(key, v) for v in value]\n+            elif isinstance(value, (list, tuple)):\n+                cleansed = [self.cleanse_setting(key, sub_value) for sub_value in value]\n             else:\n                 cleansed = value\n         except TypeError:\n",
        "model": "deepseek-coder",
        "message": "Applied the change to django/views/debug.py.\n\n<scratch_pad>\n```xml\n</scratch_pad>",
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": [],
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "modify",
            "finish": null,
            "reject": null,
            "span_id": "SafeExceptionReporterFilter.cleanse_setting",
            "file_path": "django/views/debug.py",
            "scratch_pad": "The updated code now handles lists and tuples, however, the recursive cleansing is not fully implemented. The cleaning should be applied not only to the top-level lists and tuples but also to any nested structures within them. We need to ensure that the cleansing process is applied recursively to all nested levels.",
            "instructions": "Update the `cleanse_setting` method to recursively handle all types of nested iterables."
          },
          "output": {
            "span_id": "SafeExceptionReporterFilter.cleanse_setting",
            "end_line": 106,
            "file_path": "django/views/debug.py",
            "start_line": 83,
            "instructions": "Update the `cleanse_setting` method to recursively handle all types of nested iterables."
          },
          "input_tokens": 2901,
          "output_tokens": 155,
          "retry_message": null,
          "completion_cost": 0.011028000000000001
        }
      ]
    },
    {
      "name": "EditCode",
      "state": {
        "model": "deepseek-coder",
        "verify": true,
        "span_id": "SafeExceptionReporterFilter.cleanse_setting",
        "end_line": 106,
        "file_path": "django/views/debug.py",
        "max_tokens": 1000,
        "start_line": 83,
        "temperature": 1.6,
        "instructions": "Update the `cleanse_setting` method to recursively handle all types of nested iterables.",
        "max_iterations": 8,
        "chain_of_thought": false,
        "show_file_context": true,
        "show_initial_message": true,
        "max_prompt_file_tokens": 4000,
        "include_message_history": true
      },
      "actions": [
        {
          "action": {
            "content": "```xml\n<replace>\n    def cleanse_setting(self, key, value):\n        \"\"\"\n        Cleanse an individual setting key/value of sensitive content. If the\n        value is a dictionary, recursively cleanse the keys in that dictionary.\n        \"\"\"\n        try:\n            if self.hidden_settings.search(key):\n                cleansed = self.cleansed_substitute\n            elif isinstance(value, dict):\n                cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n            elif isinstance(value, list):\n                cleansed = [self.cleanse_setting(key, v) for v in value]\n            elif isinstance(value, (list, tuple, set)):\n                cleansed = type(value)(self.cleanse_setting(key, sub_value) for sub_value in value)\n            elif isinstance(value, (dict, list, tuple, set)):\n                cleansed = type(value)(self.cleanse_setting(key, sub_value) for sub_value in value)\n            else:\n                cleansed = value\n        except TypeError:\n            # If the key isn't regex-able, just return as-is.\n            cleansed = value\n\n        if callable(cleansed):\n            cleansed = CallableSettingWrapper(cleansed)\n\n        return cleansed\n</replace>"
          },
          "output": {
            "diff": "--- django/views/debug.py\n+++ django/views/debug.py\n@@ -92,8 +92,10 @@\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n             elif isinstance(value, list):\n                 cleansed = [self.cleanse_setting(key, v) for v in value]\n-            elif isinstance(value, (list, tuple)):\n-                cleansed = [self.cleanse_setting(key, sub_value) for sub_value in value]\n+            elif isinstance(value, (list, tuple, set)):\n+                cleansed = type(value)(self.cleanse_setting(key, sub_value) for sub_value in value)\n+            elif isinstance(value, (dict, list, tuple, set)):\n+                cleansed = type(value)(self.cleanse_setting(key, sub_value) for sub_value in value)\n             else:\n                 cleansed = value\n         except TypeError:\n",
            "message": "Applied the change to django/views/debug.py.\n\n<scratch_pad>\n```xml\n</scratch_pad>",
            "verification_errors": []
          },
          "input_tokens": 2186,
          "output_tokens": 316,
          "retry_message": null,
          "completion_cost": 0.011298
        }
      ]
    },
    {
      "name": "PlanToCode",
      "state": {
        "diff": "--- django/views/debug.py\n+++ django/views/debug.py\n@@ -92,8 +92,10 @@\n                 cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n             elif isinstance(value, list):\n                 cleansed = [self.cleanse_setting(key, v) for v in value]\n-            elif isinstance(value, (list, tuple)):\n-                cleansed = [self.cleanse_setting(key, sub_value) for sub_value in value]\n+            elif isinstance(value, (list, tuple, set)):\n+                cleansed = type(value)(self.cleanse_setting(key, sub_value) for sub_value in value)\n+            elif isinstance(value, (dict, list, tuple, set)):\n+                cleansed = type(value)(self.cleanse_setting(key, sub_value) for sub_value in value)\n             else:\n                 cleansed = value\n         except TypeError:\n",
        "model": "deepseek-coder",
        "message": "Applied the change to django/views/debug.py.\n\n<scratch_pad>\n```xml\n</scratch_pad>",
        "max_tokens": 1000,
        "temperature": 1.6,
        "max_iterations": 8,
        "finish_on_review": false,
        "verification_errors": [],
        "max_prompt_file_tokens": 4000,
        "include_message_history": true,
        "allow_hallucinated_spans": false,
        "max_tokens_in_edit_prompt": 500,
        "expand_context_with_related_spans": true
      },
      "actions": [
        {
          "action": {
            "action": "finish",
            "finish": "The issue of insufficiently cleaned settings has been fully addressed by ensuring that the `cleanse_setting` method correctly handles and recursively cleanses all types of iterables.",
            "reject": null,
            "span_id": null,
            "file_path": null,
            "scratch_pad": "The updated code now correctly handles all types of nested iterables, including lists, tuples, and sets. The cleansing process is applied recursively to ensure that all nested levels are properly cleansed. This should address the issue of sensitive information exposure.",
            "instructions": null
          },
          "output": {
            "message": "The issue of insufficiently cleaned settings has been fully addressed by ensuring that the `cleanse_setting` method correctly handles and recursively cleanses all types of iterables."
          },
          "input_tokens": 3389,
          "output_tokens": 144,
          "retry_message": null,
          "completion_cost": 0.012327000000000001
        }
      ]
    },
    {
      "name": "Finished",
      "state": {
        "model": "gpt-4o",
        "output": {
          "model": "deepseek-coder",
          "temperature": 1.6
        },
        "message": "The issue of insufficiently cleaned settings has been fully addressed by ensuring that the `cleanse_setting` method correctly handles and recursively cleanses all types of iterables.",
        "max_tokens": 1000,
        "temperature": 0.0,
        "max_iterations": null,
        "include_message_history": false
      },
      "actions": []
    }
  ],
  "initial_message": "Settings are cleaned insufficiently.\nDescription\n\t\nPosting publicly after checking with the rest of the security team.\nI just ran into a case where django.views.debug.SafeExceptionReporterFilter.get_safe_settings() would return several un-cleansed values. Looking at cleanse_setting() I realized that we \u200bonly take care of `dict`s but don't take other types of iterables into account but \u200breturn them as-is.\nExample:\nIn my settings.py I have this:\nMY_SETTING = {\n\t\"foo\": \"value\",\n\t\"secret\": \"value\",\n\t\"token\": \"value\",\n\t\"something\": [\n\t\t{\"foo\": \"value\"},\n\t\t{\"secret\": \"value\"},\n\t\t{\"token\": \"value\"},\n\t],\n\t\"else\": [\n\t\t[\n\t\t\t{\"foo\": \"value\"},\n\t\t\t{\"secret\": \"value\"},\n\t\t\t{\"token\": \"value\"},\n\t\t],\n\t\t[\n\t\t\t{\"foo\": \"value\"},\n\t\t\t{\"secret\": \"value\"},\n\t\t\t{\"token\": \"value\"},\n\t\t],\n\t]\n}\nOn Django 3.0 and below:\n>>> import pprint\n>>> from django.views.debug import get_safe_settings\n>>> pprint.pprint(get_safe_settings()[\"MY_SETTING\"])\n{'else': [[{'foo': 'value'}, {'secret': 'value'}, {'token': 'value'}],\n\t\t [{'foo': 'value'}, {'secret': 'value'}, {'token': 'value'}]],\n 'foo': 'value',\n 'secret': '********************',\n 'something': [{'foo': 'value'}, {'secret': 'value'}, {'token': 'value'}],\n 'token': '********************'}\nOn Django 3.1 and up:\n>>> from django.views.debug import SafeExceptionReporterFilter\n>>> import pprint\n>>> pprint.pprint(SafeExceptionReporterFilter().get_safe_settings()[\"MY_SETTING\"])\n{'else': [[{'foo': 'value'}, {'secret': 'value'}, {'token': 'value'}],\n\t\t [{'foo': 'value'}, {'secret': 'value'}, {'token': 'value'}]],\n 'foo': 'value',\n 'secret': '********************',\n 'something': [{'foo': 'value'}, {'secret': 'value'}, {'token': 'value'}],\n 'token': '********************'}\n"
}